// tslint:disable
/**
 * Gaia-Lite for Cosmos
 * A REST interface for state queries, transaction generation and broadcasting.
 *
 * The version of the OpenAPI document: 3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface BaseReq
 */
export interface BaseReq {
  /**
   * Sender address or Keybase name to generate a transaction
   * @type {string}
   * @memberof BaseReq
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  memo?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  account_number?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  sequence?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  gas?: string;
  /**
   *
   * @type {string}
   * @memberof BaseReq
   */
  gas_adjustment?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof BaseReq
   */
  fees?: Array<Coin>;
  /**
   * Estimate gas for a transaction (cannot be used in conjunction with generate_only)
   * @type {boolean}
   * @memberof BaseReq
   */
  simulate?: boolean;
}
/**
 *
 * @export
 * @interface Block
 */
export interface Block {
  /**
   *
   * @type {BlockHeader}
   * @memberof Block
   */
  header?: BlockHeader;
  /**
   *
   * @type {Array<string>}
   * @memberof Block
   */
  txs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Block
   */
  evidence?: Array<string>;
  /**
   *
   * @type {BlockLastCommit}
   * @memberof Block
   */
  last_commit?: BlockLastCommit;
}
/**
 *
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  chain_id?: string;
  /**
   *
   * @type {number}
   * @memberof BlockHeader
   */
  height?: number;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  time?: string;
  /**
   *
   * @type {number}
   * @memberof BlockHeader
   */
  num_txs?: number;
  /**
   *
   * @type {BlockID}
   * @memberof BlockHeader
   */
  last_block_id?: BlockID;
  /**
   *
   * @type {number}
   * @memberof BlockHeader
   */
  total_txs?: number;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  last_commit_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  data_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  validators_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  next_validators_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  consensus_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  app_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  last_results_hash?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeader
   */
  evidence_hash?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof BlockHeader
   */
  proposer_address?: string;
  /**
   *
   * @type {BlockHeaderVersion}
   * @memberof BlockHeader
   */
  version?: BlockHeaderVersion;
}
/**
 *
 * @export
 * @interface BlockHeaderVersion
 */
export interface BlockHeaderVersion {
  /**
   *
   * @type {string}
   * @memberof BlockHeaderVersion
   */
  block?: string;
  /**
   *
   * @type {string}
   * @memberof BlockHeaderVersion
   */
  app?: string;
}
/**
 *
 * @export
 * @interface BlockID
 */
export interface BlockID {
  /**
   *
   * @type {string}
   * @memberof BlockID
   */
  hash?: string;
  /**
   *
   * @type {BlockIDParts}
   * @memberof BlockID
   */
  parts?: BlockIDParts;
}
/**
 *
 * @export
 * @interface BlockIDParts
 */
export interface BlockIDParts {
  /**
   *
   * @type {number}
   * @memberof BlockIDParts
   */
  total?: number;
  /**
   *
   * @type {string}
   * @memberof BlockIDParts
   */
  hash?: string;
}
/**
 *
 * @export
 * @interface BlockLastCommit
 */
export interface BlockLastCommit {
  /**
   *
   * @type {BlockID}
   * @memberof BlockLastCommit
   */
  block_id?: BlockID;
  /**
   *
   * @type {Array<BlockLastCommitPrecommits>}
   * @memberof BlockLastCommit
   */
  precommits?: Array<BlockLastCommitPrecommits>;
}
/**
 *
 * @export
 * @interface BlockLastCommitPrecommits
 */
export interface BlockLastCommitPrecommits {
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  validator_address?: string;
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  validator_index?: string;
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  height?: string;
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  round?: string;
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  timestamp?: string;
  /**
   *
   * @type {number}
   * @memberof BlockLastCommitPrecommits
   */
  type?: number;
  /**
   *
   * @type {BlockID}
   * @memberof BlockLastCommitPrecommits
   */
  block_id?: BlockID;
  /**
   *
   * @type {string}
   * @memberof BlockLastCommitPrecommits
   */
  signature?: string;
}
/**
 *
 * @export
 * @interface BlockQuery
 */
export interface BlockQuery {
  /**
   *
   * @type {BlockQueryBlockMeta}
   * @memberof BlockQuery
   */
  block_meta?: BlockQueryBlockMeta;
  /**
   *
   * @type {Block}
   * @memberof BlockQuery
   */
  block?: Block;
}
/**
 *
 * @export
 * @interface BlockQueryBlockMeta
 */
export interface BlockQueryBlockMeta {
  /**
   *
   * @type {BlockHeader}
   * @memberof BlockQueryBlockMeta
   */
  header?: BlockHeader;
  /**
   *
   * @type {BlockID}
   * @memberof BlockQueryBlockMeta
   */
  block_id?: BlockID;
}
/**
 *
 * @export
 * @interface BroadcastTxCommitResult
 */
export interface BroadcastTxCommitResult {
  /**
   *
   * @type {CheckTxResult}
   * @memberof BroadcastTxCommitResult
   */
  check_tx?: CheckTxResult;
  /**
   *
   * @type {DeliverTxResult}
   * @memberof BroadcastTxCommitResult
   */
  deliver_tx?: DeliverTxResult;
  /**
   *
   * @type {string}
   * @memberof BroadcastTxCommitResult
   */
  txhash?: string;
  /**
   *
   * @type {number}
   * @memberof BroadcastTxCommitResult
   */
  height?: number;
}
/**
 *
 * @export
 * @interface Channel
 */
export interface Channel {
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  ordering?: string;
  /**
   *
   * @type {ChannelCounterparty}
   * @memberof Channel
   */
  counterparty?: ChannelCounterparty;
  /**
   *
   * @type {Array<string>}
   * @memberof Channel
   */
  connection_hops?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  version?: string;
}
/**
 *
 * @export
 * @interface ChannelCounterparty
 */
export interface ChannelCounterparty {
  /**
   *
   * @type {string}
   * @memberof ChannelCounterparty
   */
  port_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelCounterparty
   */
  channel_id?: string;
}
/**
 *
 * @export
 * @interface ChannelResponse
 */
export interface ChannelResponse {
  /**
   *
   * @type {Channel}
   * @memberof ChannelResponse
   */
  channel?: Channel;
  /**
   *
   * @type {Proof}
   * @memberof ChannelResponse
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof ChannelResponse
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof ChannelResponse
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface CheckTxResult
 */
export interface CheckTxResult {
  /**
   *
   * @type {number}
   * @memberof CheckTxResult
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof CheckTxResult
   */
  data?: string;
  /**
   *
   * @type {number}
   * @memberof CheckTxResult
   */
  gas_used?: number;
  /**
   *
   * @type {number}
   * @memberof CheckTxResult
   */
  gas_wanted?: number;
  /**
   *
   * @type {string}
   * @memberof CheckTxResult
   */
  info?: string;
  /**
   *
   * @type {string}
   * @memberof CheckTxResult
   */
  log?: string;
  /**
   *
   * @type {Array<KVPair>}
   * @memberof CheckTxResult
   */
  tags?: Array<KVPair>;
}
/**
 *
 * @export
 * @interface ClientConnectionsResponse
 */
export interface ClientConnectionsResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof ClientConnectionsResponse
   */
  connection_paths?: Array<string>;
  /**
   *
   * @type {Proof}
   * @memberof ClientConnectionsResponse
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof ClientConnectionsResponse
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof ClientConnectionsResponse
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ClientState
 */
export interface ClientState {
  /**
   *
   * @type {string}
   * @memberof ClientState
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof ClientState
   */
  frozen?: boolean;
}
/**
 *
 * @export
 * @interface Coin
 */
export interface Coin {
  /**
   *
   * @type {string}
   * @memberof Coin
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof Coin
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface Commit
 */
export interface Commit {
  /**
   *
   * @type {BlockID}
   * @memberof Commit
   */
  block_id?: BlockID;
  /**
   *
   * @type {Array<BlockLastCommitPrecommits>}
   * @memberof Commit
   */
  precommits?: Array<BlockLastCommitPrecommits>;
}
/**
 *
 * @export
 * @interface Connection
 */
export interface Connection {
  /**
   *
   * @type {string}
   * @memberof Connection
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof Connection
   */
  client_id?: string;
  /**
   *
   * @type {ConnectionCounterparty}
   * @memberof Connection
   */
  counterparty?: ConnectionCounterparty;
  /**
   *
   * @type {Array<string>}
   * @memberof Connection
   */
  versions?: Array<string>;
}
/**
 *
 * @export
 * @interface ConnectionCounterparty
 */
export interface ConnectionCounterparty {
  /**
   *
   * @type {string}
   * @memberof ConnectionCounterparty
   */
  client_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionCounterparty
   */
  connection_id?: string;
  /**
   *
   * @type {PrefixValue}
   * @memberof ConnectionCounterparty
   */
  prefix?: PrefixValue;
}
/**
 *
 * @export
 * @interface ConnectionResponse
 */
export interface ConnectionResponse {
  /**
   *
   * @type {Connection}
   * @memberof ConnectionResponse
   */
  connection?: Connection;
  /**
   *
   * @type {Proof}
   * @memberof ConnectionResponse
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof ConnectionResponse
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof ConnectionResponse
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ConsensusState
 */
export interface ConsensusState {
  /**
   *
   * @type {string}
   * @memberof ConsensusState
   */
  chain_id?: string;
  /**
   *
   * @type {number}
   * @memberof ConsensusState
   */
  height?: number;
  /**
   *
   * @type {Root}
   * @memberof ConsensusState
   */
  root?: Root;
  /**
   *
   * @type {ValidatorSet}
   * @memberof ConsensusState
   */
  next_validator_set?: ValidatorSet;
}
/**
 *
 * @export
 * @interface Delegation
 */
export interface Delegation {
  /**
   *
   * @type {string}
   * @memberof Delegation
   */
  delegator_address?: string;
  /**
   *
   * @type {string}
   * @memberof Delegation
   */
  validator_address?: string;
  /**
   *
   * @type {string}
   * @memberof Delegation
   */
  shares?: string;
  /**
   *
   * @type {Coin}
   * @memberof Delegation
   */
  balance?: Coin;
}
/**
 *
 * @export
 * @interface DelegationDelegatorReward
 */
export interface DelegationDelegatorReward {
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof DelegationDelegatorReward
   */
  validator_address?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof DelegationDelegatorReward
   */
  reward?: Array<Coin>;
}
/**
 *
 * @export
 * @interface DelegatorTotalRewards
 */
export interface DelegatorTotalRewards {
  /**
   *
   * @type {Array<DelegationDelegatorReward>}
   * @memberof DelegatorTotalRewards
   */
  rewards?: Array<DelegationDelegatorReward>;
  /**
   *
   * @type {Array<Coin>}
   * @memberof DelegatorTotalRewards
   */
  total?: Array<Coin>;
}
/**
 *
 * @export
 * @interface DeliverTxResult
 */
export interface DeliverTxResult {
  /**
   *
   * @type {number}
   * @memberof DeliverTxResult
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof DeliverTxResult
   */
  data?: string;
  /**
   *
   * @type {number}
   * @memberof DeliverTxResult
   */
  gas_used?: number;
  /**
   *
   * @type {number}
   * @memberof DeliverTxResult
   */
  gas_wanted?: number;
  /**
   *
   * @type {string}
   * @memberof DeliverTxResult
   */
  info?: string;
  /**
   *
   * @type {string}
   * @memberof DeliverTxResult
   */
  log?: string;
  /**
   *
   * @type {Array<KVPair>}
   * @memberof DeliverTxResult
   */
  tags?: Array<KVPair>;
}
/**
 *
 * @export
 * @interface Deposit
 */
export interface Deposit {
  /**
   *
   * @type {Array<Coin>}
   * @memberof Deposit
   */
  amount?: Array<Coin>;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  proposal_id?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof Deposit
   */
  depositor?: string;
}
/**
 *
 * @export
 * @interface Evidence
 */
export interface Evidence {
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  type?: string;
  /**
   *
   * @type {EvidenceValue}
   * @memberof Evidence
   */
  value?: EvidenceValue;
}
/**
 *
 * @export
 * @interface EvidenceValue
 */
export interface EvidenceValue {
  /**
   *
   * @type {string}
   * @memberof EvidenceValue
   */
  DuplicateVoteEvidence?: string;
  /**
   *
   * @type {string}
   * @memberof EvidenceValue
   */
  chain_id?: string;
  /**
   *
   * @type {number}
   * @memberof EvidenceValue
   */
  val_power?: number;
  /**
   *
   * @type {number}
   * @memberof EvidenceValue
   */
  total_power?: number;
}
/**
 *
 * @export
 * @interface Header
 */
export interface Header {
  /**
   *
   * @type {string}
   * @memberof Header
   */
  type?: string;
  /**
   *
   * @type {HeaderValue}
   * @memberof Header
   */
  value?: HeaderValue;
}
/**
 *
 * @export
 * @interface HeaderValue
 */
export interface HeaderValue {
  /**
   *
   * @type {SignedHeader}
   * @memberof HeaderValue
   */
  SignedHeader?: SignedHeader;
  /**
   *
   * @type {ValidatorSet}
   * @memberof HeaderValue
   */
  validator_set?: ValidatorSet;
  /**
   *
   * @type {ValidatorSet}
   * @memberof HeaderValue
   */
  next_validator_set?: ValidatorSet;
}
/**
 *
 * @export
 * @interface IBCValidator
 */
export interface IBCValidator {
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof IBCValidator
   */
  address?: string;
  /**
   *
   * @type {IBCValidatorPubKey}
   * @memberof IBCValidator
   */
  pub_key?: IBCValidatorPubKey;
  /**
   *
   * @type {string}
   * @memberof IBCValidator
   */
  voting_power?: string;
  /**
   *
   * @type {string}
   * @memberof IBCValidator
   */
  proposer_priority?: string;
}
/**
 *
 * @export
 * @interface IBCValidatorPubKey
 */
export interface IBCValidatorPubKey {
  /**
   *
   * @type {string}
   * @memberof IBCValidatorPubKey
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof IBCValidatorPubKey
   */
  value?: string;
}
/**
 *
 * @export
 * @interface IbcClientsConsensusState
 */
export interface IbcClientsConsensusState {
  /**
   *
   * @type {string}
   * @memberof IbcClientsConsensusState
   */
  type?: string;
  /**
   *
   * @type {ConsensusState}
   * @memberof IbcClientsConsensusState
   */
  value?: ConsensusState;
}
/**
 *
 * @export
 * @interface IbcConnectionsOpenTryProofInit
 */
export interface IbcConnectionsOpenTryProofInit {
  /**
   *
   * @type {string}
   * @memberof IbcConnectionsOpenTryProofInit
   */
  type?: string;
  /**
   *
   * @type {Proof}
   * @memberof IbcConnectionsOpenTryProofInit
   */
  value?: Proof;
}
/**
 *
 * @export
 * @interface BroadcastReq
 */
export interface BroadcastReq {
  /**
   *
   * @type {StdTx}
   * @memberof BroadcastReq
   */
  tx?: StdTx;
  /**
   *
   * @type {string}
   * @memberof BroadcastReq
   */
  mode?: "sync" | "async" | "block";
}
/**
 *
 * @export
 * @interface EncodeReq
 */
export interface EncodeReq {
  /**
   *
   * @type {StdTx}
   * @memberof EncodeReq
   */
  tx?: StdTx;
}
/**
 *
 * @export
 * @interface DepositReq
 */
export interface DepositReq {
  /**
   *
   * @type {BaseReq}
   * @memberof DepositReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof DepositReq
   */
  depositor?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof DepositReq
   */
  amount?: Array<Coin>;
}
/**
 *
 * @export
 * @interface VoteReq
 */
export interface VoteReq {
  /**
   *
   * @type {BaseReq}
   * @memberof VoteReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof VoteReq
   */
  voter?: string;
  /**
   *
   * @type {string}
   * @memberof VoteReq
   */
  option?: string;
}
/**
 *
 * @export
 * @interface WithdrawRewardsReq
 */
export interface WithdrawRewardsReq {
  /**
   *
   * @type {BaseReq}
   * @memberof WithdrawRewardsReq
   */
  base_req?: BaseReq;
}
/**
 *
 * @export
 * @interface WithdrawRewardsReq
 */
export interface WithdrawRewardsReq {
  /**
   *
   * @type {BaseReq}
   * @memberof WithdrawRewardsReq
   */
  base_req?: BaseReq;
}
/**
 *
 * @export
 * @interface SetWithdrawAddressReq
 */
export interface SetWithdrawAddressReq {
  /**
   *
   * @type {BaseReq}
   * @memberof SetWithdrawAddressReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof SetWithdrawAddressReq
   */
  withdraw_address?: string;
}
/**
 *
 * @export
 * @interface WithdrawRewardsReq
 */
export interface WithdrawRewardsReq {
  /**
   *
   * @type {BaseReq}
   * @memberof WithdrawRewardsReq
   */
  base_req?: BaseReq;
}
/**
 *
 * @export
 * @interface CreateClientReq
 */
export interface CreateClientReq {
  /**
   *
   * @type {BaseReq}
   * @memberof CreateClientReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof CreateClientReq
   */
  client_id?: string;
  /**
   *
   * @type {IbcClientsConsensusState}
   * @memberof CreateClientReq
   */
  consensus_state?: IbcClientsConsensusState;
}
/**
 *
 * @export
 * @interface UpdateClientReq
 */
export interface UpdateClientReq {
  /**
   *
   * @type {BaseReq}
   * @memberof UpdateClientReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {Header}
   * @memberof UpdateClientReq
   */
  header?: Header;
}
/**
 *
 * @export
 * @interface SubmitMisbehaviourReq
 */
export interface SubmitMisbehaviourReq {
  /**
   *
   * @type {BaseReq}
   * @memberof SubmitMisbehaviourReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {Evidence}
   * @memberof SubmitMisbehaviourReq
   */
  evidence?: Evidence;
}
/**
 *
 * @export
 * @interface ConnectionOpenInitReq
 */
export interface ConnectionOpenInitReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ConnectionOpenInitReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenInitReq
   */
  connection_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenInitReq
   */
  client_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenInitReq
   */
  counterparty_client_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenInitReq
   */
  counterparty_connection_id?: string;
  /**
   *
   * @type {Prefix}
   * @memberof ConnectionOpenInitReq
   */
  counterparty_prefix?: Prefix;
}
/**
 *
 * @export
 * @interface DecodeReq
 */
export interface DecodeReq {
  /**
   *
   * @type {string}
   * @memberof DecodeReq
   */
  tx?: string;
}
/**
 *
 * @export
 * @interface ConnectionOpenTryReq
 */
export interface ConnectionOpenTryReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ConnectionOpenTryReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenTryReq
   */
  connection_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenTryReq
   */
  client_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenTryReq
   */
  counterparty_client_id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenTryReq
   */
  counterparty_connection_id?: string;
  /**
   *
   * @type {Prefix}
   * @memberof ConnectionOpenTryReq
   */
  counterparty_prefix?: Prefix;
  /**
   *
   * @type {Array<string>}
   * @memberof ConnectionOpenTryReq
   */
  counterparty_versions?: Array<string>;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ConnectionOpenTryReq
   */
  proof_init?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ConnectionOpenTryReq
   */
  proof_consensus?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ConnectionOpenTryReq
   */
  proof_height?: number;
  /**
   *
   * @type {number}
   * @memberof ConnectionOpenTryReq
   */
  consensus_height?: number;
}
/**
 *
 * @export
 * @interface ConnectionOpenAckReq
 */
export interface ConnectionOpenAckReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ConnectionOpenAckReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ConnectionOpenAckReq
   */
  proof_try?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ConnectionOpenAckReq
   */
  proof_consensus?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ConnectionOpenAckReq
   */
  proof_height?: number;
  /**
   *
   * @type {number}
   * @memberof ConnectionOpenAckReq
   */
  consensus_height?: number;
  /**
   *
   * @type {string}
   * @memberof ConnectionOpenAckReq
   */
  version?: string;
}
/**
 *
 * @export
 * @interface ConnectionOpenConfirmReq
 */
export interface ConnectionOpenConfirmReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ConnectionOpenConfirmReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ConnectionOpenConfirmReq
   */
  proof_ack?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ConnectionOpenConfirmReq
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ChannelOpenInitReq
 */
export interface ChannelOpenInitReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelOpenInitReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  port_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  channel_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  channel_order?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ChannelOpenInitReq
   */
  connection_hops?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  counterparty_port_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenInitReq
   */
  counterparty_channel_id?: string;
}
/**
 *
 * @export
 * @interface ChannelOpenTryReq
 */
export interface ChannelOpenTryReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelOpenTryReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  port_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  channel_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  channel_order?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ChannelOpenTryReq
   */
  connection_hops?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  counterparty_port_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  counterparty_channel_id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenTryReq
   */
  counterparty_version?: string;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ChannelOpenTryReq
   */
  proof_init?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ChannelOpenTryReq
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ChannelOpenAckReq
 */
export interface ChannelOpenAckReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelOpenAckReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ChannelOpenAckReq
   */
  counterparty_version?: string;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ChannelOpenAckReq
   */
  proof_try?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ChannelOpenAckReq
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ChannelOpenConfirmReq
 */
export interface ChannelOpenConfirmReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelOpenConfirmReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ChannelOpenConfirmReq
   */
  proof_ack?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ChannelOpenConfirmReq
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface ChannelCloseInitReq
 */
export interface ChannelCloseInitReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelCloseInitReq
   */
  base_req?: BaseReq;
}
/**
 *
 * @export
 * @interface ChannelCloseConfirmReq
 */
export interface ChannelCloseConfirmReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ChannelCloseConfirmReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {IbcConnectionsOpenTryProofInit}
   * @memberof ChannelCloseConfirmReq
   */
  proof_init?: IbcConnectionsOpenTryProofInit;
  /**
   *
   * @type {number}
   * @memberof ChannelCloseConfirmReq
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface TransferTokenReq
 */
export interface TransferTokenReq {
  /**
   *
   * @type {BaseReq}
   * @memberof TransferTokenReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {Array<Coin>}
   * @memberof TransferTokenReq
   */
  amount?: Array<Coin>;
  /**
   *
   * @type {string}
   * @memberof TransferTokenReq
   */
  receiver?: string;
  /**
   *
   * @type {boolean}
   * @memberof TransferTokenReq
   */
  source?: boolean;
}
/**
 *
 * @export
 * @interface SendReq
 */
export interface SendReq {
  /**
   *
   * @type {BaseReq}
   * @memberof SendReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {Array<Coin>}
   * @memberof SendReq
   */
  amount?: Array<Coin>;
}
/**
 *
 * @export
 * @interface ReceivedPacketReq
 */
export interface ReceivedPacketReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ReceivedPacketReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {Packet}
   * @memberof ReceivedPacketReq
   */
  packet?: Packet;
  /**
   *
   * @type {Array<Proof>}
   * @memberof ReceivedPacketReq
   */
  proofs?: Array<Proof>;
  /**
   *
   * @type {number}
   * @memberof ReceivedPacketReq
   */
  height?: number;
}
/**
 *
 * @export
 * @interface DelegateReq
 */
export interface DelegateReq {
  /**
   *
   * @type {BaseReq}
   * @memberof DelegateReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof DelegateReq
   */
  delegator_address?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof DelegateReq
   */
  validator_address?: string;
  /**
   *
   * @type {Coin}
   * @memberof DelegateReq
   */
  delegation?: Coin;
}
/**
 *
 * @export
 * @interface UndelegateReq
 */
export interface UndelegateReq {
  /**
   *
   * @type {BaseReq}
   * @memberof UndelegateReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof UndelegateReq
   */
  delegator_address?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof UndelegateReq
   */
  validator_address?: string;
  /**
   *
   * @type {string}
   * @memberof UndelegateReq
   */
  shares?: string;
}
/**
 *
 * @export
 * @interface RedelegateReq
 */
export interface RedelegateReq {
  /**
   *
   * @type {BaseReq}
   * @memberof RedelegateReq
   */
  base_req?: BaseReq;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof RedelegateReq
   */
  delegator_address?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof RedelegateReq
   */
  validator_src_addressess?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof Redelegateeq
   */
  validator_dst_address?: string;
  /**
   *
   * @type {string}
   * @memberof RedelegateReq
   */
  shares?: string;
}
/**
 *
 * @export
 * @interface UnjailReq
 */
export interface UnjailReq {
  /**
   *
   * @type {BaseReq}
   * @memberof UnjailReq
   */
  base_req?: BaseReq;
}
/**
 *
 * @export
 * @interface PostProposalReq
 */
export interface PostProposalReq {
  /**
   *
   * @type {BaseReq}
   * @memberof PostProposalReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof PostProposalReq
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof PostProposalReq
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PostProposalReq
   */
  proposal_type?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof PostProposalReq
   */
  proposer?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof PostProposalReq
   */
  initial_deposit?: Array<Coin>;
}
/**
 *
 * @export
 * @interface ParamChangeProposalReq
 */
export interface ParamChangeProposalReq {
  /**
   *
   * @type {BaseReq}
   * @memberof ParamChangeProposalReq
   */
  base_req?: BaseReq;
  /**
   *
   * @type {string}
   * @memberof ParamChangeProposalReq
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ParamChangeProposalReq
   */
  description?: string;
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof ParamChangeProposalReq
   */
  proposer?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof ParamChangeProposalReq
   */
  deposit?: Array<Coin>;
  /**
   *
   * @type {Array<ParamChange>}
   * @memberof ParamChangeProposalReq
   */
  changes?: Array<ParamChange>;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {InlineResponse200ApplicationVersion}
   * @memberof InlineResponse200
   */
  application_version?: InlineResponse200ApplicationVersion;
  /**
   *
   * @type {InlineResponse200NodeInfo}
   * @memberof InlineResponse200
   */
  node_info?: InlineResponse200NodeInfo;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2001
   */
  syncing?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {ClientState}
   * @memberof InlineResponse20010
   */
  client_state?: ClientState;
  /**
   *
   * @type {Proof}
   * @memberof InlineResponse20010
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof InlineResponse20010
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {Root}
   * @memberof InlineResponse20011
   */
  root?: Root;
  /**
   *
   * @type {Proof}
   * @memberof InlineResponse20011
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof InlineResponse20011
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002
   */
  block_height?: string;
  /**
   *
   * @type {Array<TendermintValidator>}
   * @memberof InlineResponse2002
   */
  validators?: Array<TendermintValidator>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  tx?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  type?: string;
  /**
   *
   * @type {BaseAccount}
   * @memberof InlineResponse2004
   */
  value?: BaseAccount;
}
/**
 *
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
  /**
   *
   * @type {string}
   * @memberof BaseAccount
   */
  account_number?: string;
  /**
   *
   * @type {string}
   * @memberof BaseAccount
   */
  address?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof BaseAccount
   */
  coins?: Array<Coin>;
  /**
   *
   * @type {PublicKey}
   * @memberof BaseAccount
   */
  public_key?: PublicKey;
  /**
   *
   * @type {string}
   * @memberof BaseAccount
   */
  sequence?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  loose_tokens?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  bonded_tokens?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  inflation_last_time?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  inflation?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  date_last_commission_reset?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  prev_bonded_shares?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  inflation_rate_change?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  inflation_max?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  inflation_min?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  goal_bonded?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  unbonding_time?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2006
   */
  max_validators?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  bond_denom?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  max_evidence_age?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  signed_blocks_window?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  min_signed_per_window?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  double_sign_unbond_duration?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  downtime_unbond_duration?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  slash_fraction_double_sign?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  slash_fraction_downtime?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {Array<Coin>}
   * @memberof InlineResponse2008
   */
  min_deposit?: Array<Coin>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008
   */
  max_deposit_period?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {ConsensusState}
   * @memberof InlineResponse2009
   */
  consensus_state?: ConsensusState;
  /**
   *
   * @type {Proof}
   * @memberof InlineResponse2009
   */
  proof?: Proof;
  /**
   *
   * @type {ProofPath}
   * @memberof InlineResponse2009
   */
  proof_path?: ProofPath;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  proof_height?: number;
}
/**
 *
 * @export
 * @interface InlineResponse200ApplicationVersion
 */
export interface InlineResponse200ApplicationVersion {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  build_tags?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  client_name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  commit?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  go?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  server_name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200ApplicationVersion
   */
  version?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200NodeInfo
 */
export interface InlineResponse200NodeInfo {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  moniker?: string;
  /**
   *
   * @type {InlineResponse200NodeInfoProtocolVersion}
   * @memberof InlineResponse200NodeInfo
   */
  protocol_version?: InlineResponse200NodeInfoProtocolVersion;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  network?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  channels?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  listen_addr?: string;
  /**
   * Tendermint version
   * @type {string}
   * @memberof InlineResponse200NodeInfo
   */
  version?: string;
  /**
   *
   * @type {InlineResponse200NodeInfoOther}
   * @memberof InlineResponse200NodeInfo
   */
  other?: InlineResponse200NodeInfoOther;
}
/**
 * more information on versions
 * @export
 * @interface InlineResponse200NodeInfoOther
 */
export interface InlineResponse200NodeInfoOther {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfoOther
   */
  tx_index?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfoOther
   */
  rpc_address?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200NodeInfoProtocolVersion
 */
export interface InlineResponse200NodeInfoProtocolVersion {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfoProtocolVersion
   */
  p2p?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfoProtocolVersion
   */
  block?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200NodeInfoProtocolVersion
   */
  app?: string;
}
/**
 *
 * @export
 * @interface KVPair
 */
export interface KVPair {
  /**
   *
   * @type {string}
   * @memberof KVPair
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof KVPair
   */
  value?: string;
}
/**
 *
 * @export
 * @interface Packet
 */
export interface Packet {
  /**
   *
   * @type {string}
   * @memberof Packet
   */
  type?: string;
  /**
   *
   * @type {PacketValue}
   * @memberof Packet
   */
  value?: PacketValue;
}
/**
 *
 * @export
 * @interface PacketValue
 */
export interface PacketValue {
  /**
   *
   * @type {number}
   * @memberof PacketValue
   */
  sequence?: number;
  /**
   *
   * @type {number}
   * @memberof PacketValue
   */
  timeout?: number;
  /**
   *
   * @type {string}
   * @memberof PacketValue
   */
  source_port?: string;
  /**
   *
   * @type {string}
   * @memberof PacketValue
   */
  source_channel?: string;
  /**
   *
   * @type {string}
   * @memberof PacketValue
   */
  destination_port?: string;
  /**
   *
   * @type {string}
   * @memberof PacketValue
   */
  destination_channel?: string;
  /**
   *
   * @type {string}
   * @memberof PacketValue
   */
  data?: string;
}
/**
 *
 * @export
 * @interface PaginatedQueryTxs
 */
export interface PaginatedQueryTxs {
  /**
   *
   * @type {number}
   * @memberof PaginatedQueryTxs
   */
  total_count?: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedQueryTxs
   */
  count?: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedQueryTxs
   */
  page_number?: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedQueryTxs
   */
  page_total?: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedQueryTxs
   */
  limit?: number;
  /**
   *
   * @type {Array<TxQuery>}
   * @memberof PaginatedQueryTxs
   */
  txs?: Array<TxQuery>;
}
/**
 *
 * @export
 * @interface ParamChange
 */
export interface ParamChange {
  /**
   *
   * @type {string}
   * @memberof ParamChange
   */
  subspace?: string;
  /**
   *
   * @type {string}
   * @memberof ParamChange
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof ParamChange
   */
  subkey?: string;
  /**
   *
   * @type {object}
   * @memberof ParamChange
   */
  value?: object;
}
/**
 *
 * @export
 * @interface Prefix
 */
export interface Prefix {
  /**
   *
   * @type {string}
   * @memberof Prefix
   */
  type?: string;
  /**
   *
   * @type {PrefixValue}
   * @memberof Prefix
   */
  value?: PrefixValue;
}
/**
 *
 * @export
 * @interface PrefixValue
 */
export interface PrefixValue {
  /**
   *
   * @type {string}
   * @memberof PrefixValue
   */
  key_prefix?: string;
}
/**
 *
 * @export
 * @interface Proof
 */
export interface Proof {
  /**
   *
   * @type {ProofProof}
   * @memberof Proof
   */
  proof?: ProofProof;
}
/**
 *
 * @export
 * @interface ProofPath
 */
export interface ProofPath {
  /**
   *
   * @type {Array<ProofPathKeyPath>}
   * @memberof ProofPath
   */
  key_path?: Array<ProofPathKeyPath>;
}
/**
 *
 * @export
 * @interface ProofPathKeyPath
 */
export interface ProofPathKeyPath {
  /**
   *
   * @type {string}
   * @memberof ProofPathKeyPath
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof ProofPathKeyPath
   */
  enc?: number;
}
/**
 *
 * @export
 * @interface ProofProof
 */
export interface ProofProof {
  /**
   *
   * @type {Array<ProofProofOps>}
   * @memberof ProofProof
   */
  ops?: Array<ProofProofOps>;
}
/**
 *
 * @export
 * @interface ProofProofOps
 */
export interface ProofProofOps {
  /**
   *
   * @type {string}
   * @memberof ProofProofOps
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ProofProofOps
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof ProofProofOps
   */
  data?: string;
}
/**
 *
 * @export
 * @interface Proposer
 */
export interface Proposer {
  /**
   *
   * @type {string}
   * @memberof Proposer
   */
  proposal_id?: string;
  /**
   *
   * @type {string}
   * @memberof Proposer
   */
  proposer?: string;
}
/**
 *
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
  /**
   *
   * @type {string}
   * @memberof PublicKey
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof PublicKey
   */
  value?: string;
}
/**
 *
 * @export
 * @interface Redelegation
 */
export interface Redelegation {
  /**
   *
   * @type {string}
   * @memberof Redelegation
   */
  delegator_address?: string;
  /**
   *
   * @type {string}
   * @memberof Redelegation
   */
  validator_src_address?: string;
  /**
   *
   * @type {string}
   * @memberof Redelegation
   */
  validator_dst_address?: string;
  /**
   *
   * @type {Array<Redelegation>}
   * @memberof Redelegation
   */
  entries?: Array<Redelegation>;
}
/**
 *
 * @export
 * @interface RedelegationEntry
 */
export interface RedelegationEntry {
  /**
   *
   * @type {number}
   * @memberof RedelegationEntry
   */
  creation_height?: number;
  /**
   *
   * @type {number}
   * @memberof RedelegationEntry
   */
  completion_time?: number;
  /**
   *
   * @type {string}
   * @memberof RedelegationEntry
   */
  initial_balance?: string;
  /**
   *
   * @type {string}
   * @memberof RedelegationEntry
   */
  balance?: string;
  /**
   *
   * @type {string}
   * @memberof RedelegationEntry
   */
  shares_dst?: string;
}
/**
 *
 * @export
 * @interface Root
 */
export interface Root {
  /**
   *
   * @type {string}
   * @memberof Root
   */
  type?: string;
  /**
   *
   * @type {RootValue}
   * @memberof Root
   */
  value?: RootValue;
}
/**
 *
 * @export
 * @interface RootValue
 */
export interface RootValue {
  /**
   *
   * @type {string}
   * @memberof RootValue
   */
  hash?: string;
}
/**
 *
 * @export
 * @interface SignedHeader
 */
export interface SignedHeader {
  /**
   *
   * @type {BlockHeader}
   * @memberof SignedHeader
   */
  header?: BlockHeader;
  /**
   *
   * @type {Commit}
   * @memberof SignedHeader
   */
  commit?: Commit;
}
/**
 *
 * @export
 * @interface SigningInfo
 */
export interface SigningInfo {
  /**
   *
   * @type {string}
   * @memberof SigningInfo
   */
  start_height?: string;
  /**
   *
   * @type {string}
   * @memberof SigningInfo
   */
  index_offset?: string;
  /**
   *
   * @type {string}
   * @memberof SigningInfo
   */
  jailed_until?: string;
  /**
   *
   * @type {string}
   * @memberof SigningInfo
   */
  missed_blocks_counter?: string;
}
/**
 *
 * @export
 * @interface StdTx
 */
export interface StdTx {
  /**
   *
   * @type {Array<string>}
   * @memberof StdTx
   */
  msg?: Array<string>;
  /**
   *
   * @type {StdTxFee}
   * @memberof StdTx
   */
  fee?: StdTxFee;
  /**
   *
   * @type {string}
   * @memberof StdTx
   */
  memo?: string;
  /**
   *
   * @type {Array<StdTxSignature>}
   * @memberof StdTx
   */
  signatures?: Array<StdTxSignature>;
}
/**
 *
 * @export
 * @interface StdTxFee
 */
export interface StdTxFee {
  /**
   *
   * @type {string}
   * @memberof StdTxFee
   */
  gas?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof StdTxFee
   */
  amount?: Array<Coin>;
}
/**
 *
 * @export
 * @interface StdTxSignature
 */
export interface StdTxSignature {
  /**
   *
   * @type {string}
   * @memberof StdTxSignature
   */
  signature?: string;
  /**
   *
   * @type {StdTxSignaturePubKey}
   * @memberof StdTxSignature
   */
  pub_key?: StdTxSignaturePubKey;
  /**
   *
   * @type {string}
   * @memberof StdTxSignature
   */
  account_number?: string;
  /**
   *
   * @type {string}
   * @memberof StdTxSignature
   */
  sequence?: string;
}
/**
 *
 * @export
 * @interface StdTxSignaturePubKey
 */
export interface StdTxSignaturePubKey {
  /**
   *
   * @type {string}
   * @memberof StdTxSignaturePubKey
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof StdTxSignaturePubKey
   */
  value?: string;
}
/**
 *
 * @export
 * @interface Supply
 */
export interface Supply {
  /**
   *
   * @type {Array<Coin>}
   * @memberof Supply
   */
  total?: Array<Coin>;
}
/**
 *
 * @export
 * @interface TallyResult
 */
export interface TallyResult {
  /**
   *
   * @type {string}
   * @memberof TallyResult
   */
  _true?: string;
  /**
   *
   * @type {string}
   * @memberof TallyResult
   */
  abstain?: string;
  /**
   *
   * @type {string}
   * @memberof TallyResult
   */
  _false?: string;
  /**
   *
   * @type {string}
   * @memberof TallyResult
   */
  no_with_veto?: string;
}
/**
 *
 * @export
 * @interface TendermintValidator
 */
export interface TendermintValidator {
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof TendermintValidator
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof TendermintValidator
   */
  pub_key?: string;
  /**
   *
   * @type {string}
   * @memberof TendermintValidator
   */
  voting_power?: string;
  /**
   *
   * @type {string}
   * @memberof TendermintValidator
   */
  proposer_priority?: string;
}
/**
 *
 * @export
 * @interface TextProposal
 */
export interface TextProposal {
  /**
   *
   * @type {number}
   * @memberof TextProposal
   */
  proposal_id?: number;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  proposal_type?: string;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  proposal_status?: string;
  /**
   *
   * @type {TallyResult}
   * @memberof TextProposal
   */
  final_tally_result?: TallyResult;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  submit_time?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof TextProposal
   */
  total_deposit?: Array<Coin>;
  /**
   *
   * @type {string}
   * @memberof TextProposal
   */
  voting_start_time?: string;
}
/**
 *
 * @export
 * @interface TxQuery
 */
export interface TxQuery {
  /**
   *
   * @type {number}
   * @memberof TxQuery
   */
  height?: number;
  /**
   *
   * @type {string}
   * @memberof TxQuery
   */
  txhash?: string;
  /**
   *
   * @type {string}
   * @memberof TxQuery
   */
  raw_log?: string;
  /**
   *
   * @type {Array<Log>}
   * @memberof TxQuery
   */
  logs?: Array<Log>;
  /**
   *
   * @type {string}
   * @memberof TxQueryResult
   */
  gas_wanted?: string;
  /**
   *
   * @type {string}
   * @memberof TxQueryResult
   */
  gas_used?: string;
  /**
   *
   * @type {StdTx}
   * @memberof TxQuery
   */
  tx?: StdTx;
  /**
   *
   * @type {string}
   * @memberof TxQuery
   */
  timestamp?: string;
}
/**
 *
 * @export
 * @interface Log
 */
export interface Log {
  /**
   *
   * @type {number}
   * @memberof Log
   */
  msg_index?: number;
  /**
   *
   * @type {string}
   * @memberof Log
   */
  log?: string;
  /**
   *
   * @type {Array<Event>}
   * @memberof Log
   */
  events?: Array<Event>;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {string}
   * @memberof Event
   */
  type?: string;
  /**
   *
   * @type {Array<KVPair>}
   * @memberof Event
   */
  attributes?: Array<KVPair>;
}
/**
 *
 * @export
 * @interface TxQueryResult
 */
export interface TxQueryResult {
  /**
   *
   * @type {string}
   * @memberof TxQueryResult
   */
  log?: string;
  /**
   *
   * @type {string}
   * @memberof TxQueryResult
   */
  gas_wanted?: string;
  /**
   *
   * @type {string}
   * @memberof TxQueryResult
   */
  gas_used?: string;
  /**
   *
   * @type {Array<KVPair>}
   * @memberof TxQueryResult
   */
  tags?: Array<KVPair>;
}
/**
 *
 * @export
 * @interface UnbondingDelegation
 */
export interface UnbondingDelegation {
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegation
   */
  delegator_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegation
   */
  validator_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegation
   */
  initial_balance?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegation
   */
  balance?: string;
  /**
   *
   * @type {number}
   * @memberof UnbondingDelegation
   */
  creation_height?: number;
  /**
   *
   * @type {number}
   * @memberof UnbondingDelegation
   */
  min_time?: number;
}
/**
 *
 * @export
 * @interface UnbondingDelegationPair
 */
export interface UnbondingDelegationPair {
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegationPair
   */
  delegator_address?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingDelegationPair
   */
  validator_address?: string;
  /**
   *
   * @type {Array<UnbondingEntries>}
   * @memberof UnbondingDelegationPair
   */
  entries?: Array<UnbondingEntries>;
}
/**
 *
 * @export
 * @interface UnbondingEntries
 */
export interface UnbondingEntries {
  /**
   *
   * @type {string}
   * @memberof UnbondingEntries
   */
  initial_balance?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingEntries
   */
  balance?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingEntries
   */
  creation_height?: string;
  /**
   *
   * @type {string}
   * @memberof UnbondingEntries
   */
  min_time?: string;
}
/**
 *
 * @export
 * @interface Validator
 */
export interface Validator {
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof Validator
   */
  operator_address?: string;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  consensus_pubkey?: string;
  /**
   *
   * @type {boolean}
   * @memberof Validator
   */
  jailed?: boolean;
  /**
   *
   * @type {number}
   * @memberof Validator
   */
  status?: number;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  tokens?: string;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  delegator_shares?: string;
  /**
   *
   * @type {ValidatorDescription}
   * @memberof Validator
   */
  description?: ValidatorDescription;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  bond_height?: string;
  /**
   *
   * @type {number}
   * @memberof Validator
   */
  bond_intra_tx_counter?: number;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  unbonding_height?: string;
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  unbonding_time?: string;
  /**
   *
   * @type {ValidatorCommission}
   * @memberof Validator
   */
  commission?: ValidatorCommission;
}
/**
 *
 * @export
 * @interface ValidatorCommission
 */
export interface ValidatorCommission {
  /**
   *
   * @type {string}
   * @memberof ValidatorCommission
   */
  rate?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorCommission
   */
  max_rate?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorCommission
   */
  max_change_rate?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorCommission
   */
  update_time?: string;
}
/**
 *
 * @export
 * @interface ValidatorDescription
 */
export interface ValidatorDescription {
  /**
   *
   * @type {string}
   * @memberof ValidatorDescription
   */
  moniker?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorDescription
   */
  identity?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorDescription
   */
  website?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorDescription
   */
  security_contact?: string;
  /**
   *
   * @type {string}
   * @memberof ValidatorDescription
   */
  details?: string;
}
/**
 *
 * @export
 * @interface ValidatorDistInfo
 */
export interface ValidatorDistInfo {
  /**
   * bech32 encoded address
   * @type {string}
   * @memberof ValidatorDistInfo
   */
  operator_address?: string;
  /**
   *
   * @type {Array<Coin>}
   * @memberof ValidatorDistInfo
   */
  self_bond_rewards?: Array<Coin>;
  /**
   *
   * @type {Array<Coin>}
   * @memberof ValidatorDistInfo
   */
  val_commission?: Array<Coin>;
}
/**
 *
 * @export
 * @interface ValidatorSet
 */
export interface ValidatorSet {
  /**
   *
   * @type {Array<IBCValidator>}
   * @memberof ValidatorSet
   */
  validators?: Array<IBCValidator>;
  /**
   *
   * @type {IBCValidator}
   * @memberof ValidatorSet
   */
  proposer?: IBCValidator;
}
/**
 *
 * @export
 * @interface Vote
 */
export interface Vote {
  /**
   *
   * @type {string}
   * @memberof Vote
   */
  voter?: string;
  /**
   *
   * @type {string}
   * @memberof Vote
   */
  proposal_id?: string;
  /**
   *
   * @type {string}
   * @memberof Vote
   */
  option?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authAccountsAddressGet(address: string, options: any = {}): RequestArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling authAccountsAddressGet.",
        );
      }
      const localVarPath = `/auth/accounts/{address}`.replace(
        `{${"address"}}`,
        encodeURIComponent(String(address)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authAccountsAddressGet(
      address: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2004> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(
        configuration,
      ).authAccountsAddressGet(address, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authAccountsAddressGet(
      address: string,
      options?: any,
    ): AxiosPromise<InlineResponse2004> {
      return AuthApiFp(configuration).authAccountsAddressGet(address, options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Get the account information on blockchain
   * @param {string} address Account address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authAccountsAddressGet(address: string, options?: any) {
    return AuthApiFp(this.configuration).authAccountsAddressGet(
      address,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * BankApi - axios parameter creator
 * @export
 */
export const BankApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {SendReq} account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountsAddressTransfersPost(
      address: string,
      account: SendReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling bankAccountsAddressTransfersPost.",
        );
      }
      // verify required parameter 'account' is not null or undefined
      if (account === null || account === undefined) {
        throw new RequiredError(
          "account",
          "Required parameter account was null or undefined when calling bankAccountsAddressTransfersPost.",
        );
      }
      const localVarPath = `/bank/accounts/{address}/transfers`.replace(
        `{${"address"}}`,
        encodeURIComponent(String(address)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof account !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(account !== undefined ? account : {})
        : account || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankBalancesAddressGet(address: string, options: any = {}): RequestArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling bankBalancesAddressGet.",
        );
      }
      const localVarPath = `/bank/balances/{address}`.replace(
        `{${"address"}}`,
        encodeURIComponent(String(address)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BankApi - functional programming interface
 * @export
 */
export const BankApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {SendReq} account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountsAddressTransfersPost(
      address: string,
      account: SendReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = BankApiAxiosParamCreator(
        configuration,
      ).bankAccountsAddressTransfersPost(address, account, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankBalancesAddressGet(
      address: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coin>> {
      const localVarAxiosArgs = BankApiAxiosParamCreator(
        configuration,
      ).bankBalancesAddressGet(address, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * BankApi - factory interface
 * @export
 */
export const BankApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {SendReq} account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountsAddressTransfersPost(
      address: string,
      account: SendReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return BankApiFp(configuration).bankAccountsAddressTransfersPost(
        address,
        account,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankBalancesAddressGet(
      address: string,
      options?: any,
    ): AxiosPromise<Array<Coin>> {
      return BankApiFp(configuration).bankBalancesAddressGet(address, options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
export class BankApi extends BaseAPI {
  /**
   *
   * @summary Send coins from one account to another
   * @param {string} address Account address in bech32 format
   * @param {SendReq} account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankApi
   */
  public bankAccountsAddressTransfersPost(
    address: string,
    account: SendReq,
    options?: any,
  ) {
    return BankApiFp(this.configuration).bankAccountsAddressTransfersPost(
      address,
      account,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get the account balances
   * @param {string} address Account address in bech32 format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankApi
   */
  public bankBalancesAddressGet(address: string, options?: any) {
    return BankApiFp(this.configuration).bankBalancesAddressGet(
      address,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * DistributionApi - axios parameter creator
 * @export
 */
export const DistributionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionCommunityPoolGet(options: any = {}): RequestArgs {
      const localVarPath = `/distribution/community_pool`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsGet(
      delegatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsGet.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsPost(
      delegatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsPost.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof withdrawRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            withdrawRequestBody !== undefined ? withdrawRequestBody : {},
          )
        : withdrawRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.",
        );
      }
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
        .replace(
          `{${"delegatorAddr"}}`,
          encodeURIComponent(String(delegatorAddr)),
        )
        .replace(
          `{${"validatorAddr"}}`,
          encodeURIComponent(String(validatorAddr)),
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
      delegatorAddr: string,
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.",
        );
      }
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
        .replace(
          `{${"delegatorAddr"}}`,
          encodeURIComponent(String(delegatorAddr)),
        )
        .replace(
          `{${"validatorAddr"}}`,
          encodeURIComponent(String(validatorAddr)),
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof withdrawRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            withdrawRequestBody !== undefined ? withdrawRequestBody : {},
          )
        : withdrawRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressGet(
      delegatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressGet.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {SetWithdrawAddressReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressPost(
      delegatorAddr: string,
      withdrawRequestBody?: SetWithdrawAddressReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling distributionDelegatorsDelegatorAddrWithdrawAddressPost.",
        );
      }
      const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof withdrawRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            withdrawRequestBody !== undefined ? withdrawRequestBody : {},
          )
        : withdrawRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionParametersGet(options: any = {}): RequestArgs {
      const localVarPath = `/distribution/parameters`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrGet.",
        );
      }
      const localVarPath = `/distribution/validators/{validatorAddr}`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrOutstandingRewardsGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrOutstandingRewardsGet.",
        );
      }
      const localVarPath = `/distribution/validators/{validatorAddr}/outstanding_rewards`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsGet.",
        );
      }
      const localVarPath = `/distribution/validators/{validatorAddr}/rewards`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsPost(
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling distributionValidatorsValidatorAddrRewardsPost.",
        );
      }
      const localVarPath = `/distribution/validators/{validatorAddr}/rewards`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof withdrawRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            withdrawRequestBody !== undefined ? withdrawRequestBody : {},
          )
        : withdrawRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DistributionApi - functional programming interface
 * @export
 */
export const DistributionApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionCommunityPoolGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coin>> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionCommunityPoolGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsGet(
      delegatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<DelegatorTotalRewards> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsPost(
      delegatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsPost(
        delegatorAddr,
        withdrawRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coin>> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
      delegatorAddr: string,
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
        delegatorAddr,
        validatorAddr,
        withdrawRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressGet(
      delegatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrWithdrawAddressGet(
        delegatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {SetWithdrawAddressReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressPost(
      delegatorAddr: string,
      withdrawRequestBody?: SetWithdrawAddressReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionDelegatorsDelegatorAddrWithdrawAddressPost(
        delegatorAddr,
        withdrawRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionParametersGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionParametersGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrGet(
      validatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<ValidatorDistInfo> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionValidatorsValidatorAddrGet(validatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrOutstandingRewardsGet(
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coin>> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionValidatorsValidatorAddrOutstandingRewardsGet(
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsGet(
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coin>> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsPost(
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = DistributionApiAxiosParamCreator(
        configuration,
      ).distributionValidatorsValidatorAddrRewardsPost(
        validatorAddr,
        withdrawRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * DistributionApi - factory interface
 * @export
 */
export const DistributionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionCommunityPoolGet(options?: any): AxiosPromise<Array<Coin>> {
      return DistributionApiFp(configuration).distributionCommunityPoolGet(
        options,
      )(axios, basePath);
    },
    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsGet(
      delegatorAddr: string,
      options?: any,
    ): AxiosPromise<DelegatorTotalRewards> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsPost(
      delegatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsPost(
        delegatorAddr,
        withdrawRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Coin>> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
      delegatorAddr: string,
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
        delegatorAddr,
        validatorAddr,
        withdrawRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressGet(
      delegatorAddr: string,
      options?: any,
    ): AxiosPromise<string> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrWithdrawAddressGet(
        delegatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {SetWithdrawAddressReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressPost(
      delegatorAddr: string,
      withdrawRequestBody?: SetWithdrawAddressReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return DistributionApiFp(
        configuration,
      ).distributionDelegatorsDelegatorAddrWithdrawAddressPost(
        delegatorAddr,
        withdrawRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionParametersGet(options?: any): AxiosPromise<object> {
      return DistributionApiFp(configuration).distributionParametersGet(
        options,
      )(axios, basePath);
    },
    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<ValidatorDistInfo> {
      return DistributionApiFp(
        configuration,
      ).distributionValidatorsValidatorAddrGet(validatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrOutstandingRewardsGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Coin>> {
      return DistributionApiFp(
        configuration,
      ).distributionValidatorsValidatorAddrOutstandingRewardsGet(
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Coin>> {
      return DistributionApiFp(
        configuration,
      ).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {WithdrawRewardsReq} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    distributionValidatorsValidatorAddrRewardsPost(
      validatorAddr: string,
      withdrawRequestBody?: WithdrawRewardsReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return DistributionApiFp(
        configuration,
      ).distributionValidatorsValidatorAddrRewardsPost(
        validatorAddr,
        withdrawRequestBody,
        options,
      )(axios, basePath);
    },
  };
};

/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
export class DistributionApi extends BaseAPI {
  /**
   *
   * @summary Community pool parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionCommunityPoolGet(options?: any) {
    return DistributionApiFp(this.configuration).distributionCommunityPoolGet(
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Get the sum of all the rewards earned by delegations by a single delegator
   * @summary Get the total rewards balance from all delegations
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrRewardsGet(
    delegatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Withdraw all the delegator\'s delegation rewards
   * @summary Withdraw all the delegator\'s delegation rewards
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {WithdrawRewardsReq} [withdrawRequestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrRewardsPost(
    delegatorAddr: string,
    withdrawRequestBody?: WithdrawRewardsReq,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrRewardsPost(
      delegatorAddr,
      withdrawRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query a single delegation reward by a delegator
   * @summary Query a delegation reward
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
    delegatorAddr: string,
    validatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(
      delegatorAddr,
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Withdraw a delegator\'s delegation reward from a single validator
   * @summary Withdraw a delegation reward
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {WithdrawRewardsReq} [withdrawRequestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
    delegatorAddr: string,
    validatorAddr: string,
    withdrawRequestBody?: WithdrawRewardsReq,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(
      delegatorAddr,
      validatorAddr,
      withdrawRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
   * @summary Get the rewards withdrawal address
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrWithdrawAddressGet(
    delegatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrWithdrawAddressGet(
      delegatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Replace the delegations\' rewards withdrawal address for a new one.
   * @summary Replace the rewards withdrawal address
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {SetWithdrawAddressReq} [withdrawRequestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionDelegatorsDelegatorAddrWithdrawAddressPost(
    delegatorAddr: string,
    withdrawRequestBody?: SetWithdrawAddressReq,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionDelegatorsDelegatorAddrWithdrawAddressPost(
      delegatorAddr,
      withdrawRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Fee distribution parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionParametersGet(options?: any) {
    return DistributionApiFp(this.configuration).distributionParametersGet(
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query the distribution information of a single validator
   * @summary Validator distribution information
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionValidatorsValidatorAddrGet(
    validatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionValidatorsValidatorAddrGet(validatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Fee distribution outstanding rewards of a single validator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionValidatorsValidatorAddrOutstandingRewardsGet(
    validatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionValidatorsValidatorAddrOutstandingRewardsGet(
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query the commission and self-delegation rewards of validator.
   * @summary Commission and self-delegation rewards of a single validator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionValidatorsValidatorAddrRewardsGet(
    validatorAddr: string,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Withdraw the validator\'s self-delegation and commissions rewards
   * @summary Withdraw the validator\'s rewards
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {WithdrawRewardsReq} [withdrawRequestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistributionApi
   */
  public distributionValidatorsValidatorAddrRewardsPost(
    validatorAddr: string,
    withdrawRequestBody?: WithdrawRewardsReq,
    options?: any,
  ) {
    return DistributionApiFp(
      this.configuration,
    ).distributionValidatorsValidatorAddrRewardsPost(
      validatorAddr,
      withdrawRequestBody,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * GaiaRESTApi - axios parameter creator
 * @export
 */
export const GaiaRESTApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nodeInfoGet(options: any = {}): RequestArgs {
      const localVarPath = `/node_info`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GaiaRESTApi - functional programming interface
 * @export
 */
export const GaiaRESTApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nodeInfoGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse200> {
      const localVarAxiosArgs = GaiaRESTApiAxiosParamCreator(
        configuration,
      ).nodeInfoGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * GaiaRESTApi - factory interface
 * @export
 */
export const GaiaRESTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nodeInfoGet(options?: any): AxiosPromise<InlineResponse200> {
      return GaiaRESTApiFp(configuration).nodeInfoGet(options)(axios, basePath);
    },
  };
};

/**
 * GaiaRESTApi - object-oriented interface
 * @export
 * @class GaiaRESTApi
 * @extends {BaseAPI}
 */
export class GaiaRESTApi extends BaseAPI {
  /**
   * Information about the connected node
   * @summary The properties of the connected node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GaiaRESTApi
   */
  public nodeInfoGet(options?: any) {
    return GaiaRESTApiFp(this.configuration).nodeInfoGet(options)(
      this.axios,
      this.basePath,
    );
  }
}

/**
 * GovernanceApi - axios parameter creator
 * @export
 */
export const GovernanceApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersDepositGet(options: any = {}): RequestArgs {
      const localVarPath = `/gov/parameters/deposit`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersTallyingGet(options: any = {}): RequestArgs {
      const localVarPath = `/gov/parameters/tallying`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersVotingGet(options: any = {}): RequestArgs {
      const localVarPath = `/gov/parameters/voting`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsGet(
      voter?: string,
      depositor?: string,
      status?: string,
      options: any = {},
    ): RequestArgs {
      const localVarPath = `/gov/proposals`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (voter !== undefined) {
        localVarQueryParameter["voter"] = voter;
      }

      if (depositor !== undefined) {
        localVarQueryParameter["depositor"] = depositor;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {ParamChangeProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsParamChangePost(
      postProposalBody: ParamChangeProposalReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'postProposalBody' is not null or undefined
      if (postProposalBody === null || postProposalBody === undefined) {
        throw new RequiredError(
          "postProposalBody",
          "Required parameter postProposalBody was null or undefined when calling govProposalsParamChangePost.",
        );
      }
      const localVarPath = `/gov/proposals/param_change`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof postProposalBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
        : postProposalBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {PostProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsPost(
      postProposalBody: PostProposalReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'postProposalBody' is not null or undefined
      if (postProposalBody === null || postProposalBody === undefined) {
        throw new RequiredError(
          "postProposalBody",
          "Required parameter postProposalBody was null or undefined when calling govProposalsPost.",
        );
      }
      const localVarPath = `/gov/proposals`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof postProposalBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(postProposalBody !== undefined ? postProposalBody : {})
        : postProposalBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsDepositorGet(
      proposalId: string,
      depositor: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.",
        );
      }
      // verify required parameter 'depositor' is not null or undefined
      if (depositor === null || depositor === undefined) {
        throw new RequiredError(
          "depositor",
          "Required parameter depositor was null or undefined when calling govProposalsProposalIdDepositsDepositorGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/deposits/{depositor}`
        .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
        .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsGet(
      proposalId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/deposits`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {DepositReq} postDepositBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsPost(
      proposalId: string,
      postDepositBody: DepositReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdDepositsPost.",
        );
      }
      // verify required parameter 'postDepositBody' is not null or undefined
      if (postDepositBody === null || postDepositBody === undefined) {
        throw new RequiredError(
          "postDepositBody",
          "Required parameter postDepositBody was null or undefined when calling govProposalsProposalIdDepositsPost.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/deposits`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof postDepositBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(postDepositBody !== undefined ? postDepositBody : {})
        : postDepositBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdGet(
      proposalId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdProposerGet(
      proposalId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdProposerGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/proposer`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdTallyGet(
      proposalId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdTallyGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/tally`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesGet(
      proposalId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/votes`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {VoteReq} postVoteBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesPost(
      proposalId: string,
      postVoteBody: VoteReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesPost.",
        );
      }
      // verify required parameter 'postVoteBody' is not null or undefined
      if (postVoteBody === null || postVoteBody === undefined) {
        throw new RequiredError(
          "postVoteBody",
          "Required parameter postVoteBody was null or undefined when calling govProposalsProposalIdVotesPost.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/votes`.replace(
        `{${"proposalId"}}`,
        encodeURIComponent(String(proposalId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof postVoteBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(postVoteBody !== undefined ? postVoteBody : {})
        : postVoteBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesVoterGet(
      proposalId: string,
      voter: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'proposalId' is not null or undefined
      if (proposalId === null || proposalId === undefined) {
        throw new RequiredError(
          "proposalId",
          "Required parameter proposalId was null or undefined when calling govProposalsProposalIdVotesVoterGet.",
        );
      }
      // verify required parameter 'voter' is not null or undefined
      if (voter === null || voter === undefined) {
        throw new RequiredError(
          "voter",
          "Required parameter voter was null or undefined when calling govProposalsProposalIdVotesVoterGet.",
        );
      }
      const localVarPath = `/gov/proposals/{proposalId}/votes/{voter}`
        .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
        .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GovernanceApi - functional programming interface
 * @export
 */
export const GovernanceApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersDepositGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2008> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govParametersDepositGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersTallyingGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govParametersTallyingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersVotingGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govParametersVotingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsGet(
      voter?: string,
      depositor?: string,
      status?: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<TextProposal>> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsGet(voter, depositor, status, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {PostProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsParamChangePost(
      postProposalBody: PostProposalReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsParamChangePost(postProposalBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {PostProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsPost(
      postProposalBody: PostProposalReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsPost(postProposalBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsDepositorGet(
      proposalId: string,
      depositor: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdDepositsDepositorGet(
        proposalId,
        depositor,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsGet(
      proposalId: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Deposit>> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdDepositsGet(proposalId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {DepositReq} postDepositBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsPost(
      proposalId: string,
      postDepositBody: DepositReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdDepositsPost(
        proposalId,
        postDepositBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdGet(
      proposalId: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<TextProposal> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdGet(proposalId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdProposerGet(
      proposalId: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposer> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdProposerGet(proposalId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdTallyGet(
      proposalId: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TallyResult> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdTallyGet(proposalId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesGet(
      proposalId: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vote>> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdVotesGet(proposalId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {VoteReq} postVoteBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesPost(
      proposalId: string,
      postVoteBody: VoteReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesVoterGet(
      proposalId: string,
      voter: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vote> {
      const localVarAxiosArgs = GovernanceApiAxiosParamCreator(
        configuration,
      ).govProposalsProposalIdVotesVoterGet(proposalId, voter, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * GovernanceApi - factory interface
 * @export
 */
export const GovernanceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersDepositGet(options?: any): AxiosPromise<InlineResponse2008> {
      return GovernanceApiFp(configuration).govParametersDepositGet(options)(
        axios,
        basePath,
      );
    },
    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersTallyingGet(options?: any): AxiosPromise<object> {
      return GovernanceApiFp(configuration).govParametersTallyingGet(options)(
        axios,
        basePath,
      );
    },
    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govParametersVotingGet(options?: any): AxiosPromise<object> {
      return GovernanceApiFp(configuration).govParametersVotingGet(options)(
        axios,
        basePath,
      );
    },
    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsGet(
      voter?: string,
      depositor?: string,
      status?: string,
      options?: any,
    ): AxiosPromise<Array<TextProposal>> {
      return GovernanceApiFp(configuration).govProposalsGet(
        voter,
        depositor,
        status,
        options,
      )(axios, basePath);
    },
    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {PostProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsParamChangePost(
      postProposalBody: PostProposalReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return GovernanceApiFp(configuration).govProposalsParamChangePost(
        postProposalBody,
        options,
      )(axios, basePath);
    },
    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {PostProposalReq} postProposalBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsPost(
      postProposalBody: PostProposalReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return GovernanceApiFp(configuration).govProposalsPost(
        postProposalBody,
        options,
      )(axios, basePath);
    },
    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsDepositorGet(
      proposalId: string,
      depositor: string,
      options?: any,
    ): AxiosPromise<Deposit> {
      return GovernanceApiFp(
        configuration,
      ).govProposalsProposalIdDepositsDepositorGet(
        proposalId,
        depositor,
        options,
      )(axios, basePath);
    },
    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsGet(
      proposalId: string,
      options?: any,
    ): AxiosPromise<Array<Deposit>> {
      return GovernanceApiFp(configuration).govProposalsProposalIdDepositsGet(
        proposalId,
        options,
      )(axios, basePath);
    },
    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {DepositReq} postDepositBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdDepositsPost(
      proposalId: string,
      postDepositBody: DepositReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return GovernanceApiFp(configuration).govProposalsProposalIdDepositsPost(
        proposalId,
        postDepositBody,
        options,
      )(axios, basePath);
    },
    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdGet(
      proposalId: string,
      options?: any,
    ): AxiosPromise<TextProposal> {
      return GovernanceApiFp(configuration).govProposalsProposalIdGet(
        proposalId,
        options,
      )(axios, basePath);
    },
    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdProposerGet(
      proposalId: string,
      options?: any,
    ): AxiosPromise<Proposer> {
      return GovernanceApiFp(configuration).govProposalsProposalIdProposerGet(
        proposalId,
        options,
      )(axios, basePath);
    },
    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdTallyGet(
      proposalId: string,
      options?: any,
    ): AxiosPromise<TallyResult> {
      return GovernanceApiFp(configuration).govProposalsProposalIdTallyGet(
        proposalId,
        options,
      )(axios, basePath);
    },
    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesGet(
      proposalId: string,
      options?: any,
    ): AxiosPromise<Array<Vote>> {
      return GovernanceApiFp(configuration).govProposalsProposalIdVotesGet(
        proposalId,
        options,
      )(axios, basePath);
    },
    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {VoteReq} postVoteBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesPost(
      proposalId: string,
      postVoteBody: VoteReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return GovernanceApiFp(configuration).govProposalsProposalIdVotesPost(
        proposalId,
        postVoteBody,
        options,
      )(axios, basePath);
    },
    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    govProposalsProposalIdVotesVoterGet(
      proposalId: string,
      voter: string,
      options?: any,
    ): AxiosPromise<Vote> {
      return GovernanceApiFp(configuration).govProposalsProposalIdVotesVoterGet(
        proposalId,
        voter,
        options,
      )(axios, basePath);
    },
  };
};

/**
 * GovernanceApi - object-oriented interface
 * @export
 * @class GovernanceApi
 * @extends {BaseAPI}
 */
export class GovernanceApi extends BaseAPI {
  /**
   * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
   * @summary Query governance deposit parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govParametersDepositGet(options?: any) {
    return GovernanceApiFp(this.configuration).govParametersDepositGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Query governance tally parameters
   * @summary Query governance tally parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govParametersTallyingGet(options?: any) {
    return GovernanceApiFp(this.configuration).govParametersTallyingGet(
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query governance voting parameters. The voting_period units are in nanoseconds.
   * @summary Query governance voting parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govParametersVotingGet(options?: any) {
    return GovernanceApiFp(this.configuration).govParametersVotingGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Query proposals information with parameters
   * @summary Query proposals
   * @param {string} [voter] voter address
   * @param {string} [depositor] depositor address
   * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsGet(
    voter?: string,
    depositor?: string,
    status?: string,
    options?: any,
  ) {
    return GovernanceApiFp(this.configuration).govProposalsGet(
      voter,
      depositor,
      status,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Generate a parameter change proposal transaction
   * @summary Generate a parameter change proposal transaction
   * @param {ParamChangeProposalReq} postProposalBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsParamChangePost(
    postProposalBody: ParamChangeProposalReq,
    options?: any,
  ) {
    return GovernanceApiFp(this.configuration).govProposalsParamChangePost(
      postProposalBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Send transaction to submit a proposal
   * @summary Submit a proposal
   * @param {PostProposalReq} postProposalBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsPost(postProposalBody: PostProposalReq, options?: any) {
    return GovernanceApiFp(this.configuration).govProposalsPost(
      postProposalBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query deposit by proposalId and depositor address
   * @summary Query deposit
   * @param {string} proposalId proposal id
   * @param {string} depositor Bech32 depositor address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdDepositsDepositorGet(
    proposalId: string,
    depositor: string,
    options?: any,
  ) {
    return GovernanceApiFp(
      this.configuration,
    ).govProposalsProposalIdDepositsDepositorGet(
      proposalId,
      depositor,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query deposits by proposalId
   * @summary Query deposits
   * @param {string} proposalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdDepositsGet(proposalId: string, options?: any) {
    return GovernanceApiFp(
      this.configuration,
    ).govProposalsProposalIdDepositsGet(proposalId, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Send transaction to deposit tokens to a proposal
   * @summary Deposit tokens to a proposal
   * @param {string} proposalId proposal id
   * @param {DepositReq} postDepositBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdDepositsPost(
    proposalId: string,
    postDepositBody: DepositReq,
    options?: any,
  ) {
    return GovernanceApiFp(
      this.configuration,
    ).govProposalsProposalIdDepositsPost(
      proposalId,
      postDepositBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query a proposal by id
   * @summary Query a proposal
   * @param {string} proposalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdGet(proposalId: string, options?: any) {
    return GovernanceApiFp(this.configuration).govProposalsProposalIdGet(
      proposalId,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query for the proposer for a proposal
   * @summary Query proposer
   * @param {string} proposalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdProposerGet(proposalId: string, options?: any) {
    return GovernanceApiFp(
      this.configuration,
    ).govProposalsProposalIdProposerGet(proposalId, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
   * @summary Get a proposal\'s tally result at the current time
   * @param {string} proposalId proposal id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdTallyGet(proposalId: string, options?: any) {
    return GovernanceApiFp(this.configuration).govProposalsProposalIdTallyGet(
      proposalId,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query voters information by proposalId
   * @summary Query voters
   * @param {string} proposalId proposal id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdVotesGet(proposalId: string, options?: any) {
    return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesGet(
      proposalId,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Send transaction to vote a proposal
   * @summary Vote a proposal
   * @param {string} proposalId proposal id
   * @param {VoteReq} postVoteBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdVotesPost(
    proposalId: string,
    postVoteBody: VoteReq,
    options?: any,
  ) {
    return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesPost(
      proposalId,
      postVoteBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Query vote information by proposal Id and voter address
   * @summary Query vote
   * @param {string} proposalId proposal id
   * @param {string} voter Bech32 voter address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GovernanceApi
   */
  public govProposalsProposalIdVotesVoterGet(
    proposalId: string,
    voter: string,
    options?: any,
  ) {
    return GovernanceApiFp(
      this.configuration,
    ).govProposalsProposalIdVotesVoterGet(
      proposalId,
      voter,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * IBCApi - axios parameter creator
 * @export
 */
export const IBCApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Channel open-init
     * @param {ChannelOpenInitReq} channelOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenInitPost(
      channelOpenInitRequestBody: ChannelOpenInitReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'channelOpenInitRequestBody' is not null or undefined
      if (
        channelOpenInitRequestBody === null ||
        channelOpenInitRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelOpenInitRequestBody",
          "Required parameter channelOpenInitRequestBody was null or undefined when calling ibcChannelsOpenInitPost.",
        );
      }
      const localVarPath = `/ibc/channels/open-init`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelOpenInitRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelOpenInitRequestBody !== undefined
              ? channelOpenInitRequestBody
              : {},
          )
        : channelOpenInitRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Channel open-try
     * @param {ChannelOpenTryReq} channelOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenTryPost(
      channelOpenTryRequestBody: ChannelOpenTryReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'channelOpenTryRequestBody' is not null or undefined
      if (
        channelOpenTryRequestBody === null ||
        channelOpenTryRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelOpenTryRequestBody",
          "Required parameter channelOpenTryRequestBody was null or undefined when calling ibcChannelsOpenTryPost.",
        );
      }
      const localVarPath = `/ibc/channels/open-try`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelOpenTryRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelOpenTryRequestBody !== undefined
              ? channelOpenTryRequestBody
              : {},
          )
        : channelOpenTryRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query client state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdClientStateGet(
      clientId: string,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdClientStateGet.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/client-state`.replace(
        `{${"client-id"}}`,
        encodeURIComponent(String(clientId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query connections of a client
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConnectionsGet(
      clientId: string,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdConnectionsGet.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/connections`.replace(
        `{${"client-id"}}`,
        encodeURIComponent(String(clientId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query cliet consensus-state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConsensusStateGet(
      clientId: string,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdConsensusStateGet.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/consensus-state`.replace(
        `{${"client-id"}}`,
        encodeURIComponent(String(clientId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit misbehaviour
     * @param {string} clientId Client ID
     * @param {SubmitMisbehaviourReq} submitMisbehaviourRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdMisbehaviourPost(
      clientId: string,
      submitMisbehaviourRequestBody: SubmitMisbehaviourReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdMisbehaviourPost.",
        );
      }
      // verify required parameter 'submitMisbehaviourRequestBody' is not null or undefined
      if (
        submitMisbehaviourRequestBody === null ||
        submitMisbehaviourRequestBody === undefined
      ) {
        throw new RequiredError(
          "submitMisbehaviourRequestBody",
          "Required parameter submitMisbehaviourRequestBody was null or undefined when calling ibcClientsClientIdMisbehaviourPost.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/misbehaviour`.replace(
        `{${"client-id"}}`,
        encodeURIComponent(String(clientId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof submitMisbehaviourRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            submitMisbehaviourRequestBody !== undefined
              ? submitMisbehaviourRequestBody
              : {},
          )
        : submitMisbehaviourRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query client root
     * @param {string} clientId Client ID
     * @param {number} height Root height
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdRootsHeightGet(
      clientId: string,
      height: number,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdRootsHeightGet.",
        );
      }
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling ibcClientsClientIdRootsHeightGet.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/roots/{height}`
        .replace(`{${"client-id"}}`, encodeURIComponent(String(clientId)))
        .replace(`{${"height"}}`, encodeURIComponent(String(height)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update client
     * @param {string} clientId Client ID
     * @param {UpdateClientReq} updateClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdUpdatePost(
      clientId: string,
      updateClientRequestBody: UpdateClientReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling ibcClientsClientIdUpdatePost.",
        );
      }
      // verify required parameter 'updateClientRequestBody' is not null or undefined
      if (
        updateClientRequestBody === null ||
        updateClientRequestBody === undefined
      ) {
        throw new RequiredError(
          "updateClientRequestBody",
          "Required parameter updateClientRequestBody was null or undefined when calling ibcClientsClientIdUpdatePost.",
        );
      }
      const localVarPath = `/ibc/clients/{client-id}/update`.replace(
        `{${"client-id"}}`,
        encodeURIComponent(String(clientId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateClientRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateClientRequestBody !== undefined
              ? updateClientRequestBody
              : {},
          )
        : updateClientRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create client
     * @param {CreateClientReq} createClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsPost(
      createClientRequestBody: CreateClientReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'createClientRequestBody' is not null or undefined
      if (
        createClientRequestBody === null ||
        createClientRequestBody === undefined
      ) {
        throw new RequiredError(
          "createClientRequestBody",
          "Required parameter createClientRequestBody was null or undefined when calling ibcClientsPost.",
        );
      }
      const localVarPath = `/ibc/clients`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createClientRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createClientRequestBody !== undefined
              ? createClientRequestBody
              : {},
          )
        : createClientRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query connection
     * @param {string} connectionId Connection ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdGet(
      connectionId: string,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling ibcConnectionsConnectionIdGet.",
        );
      }
      const localVarPath = `/ibc/connections/{connection-id}`.replace(
        `{${"connection-id"}}`,
        encodeURIComponent(String(connectionId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Connection open-ack
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenAckReq} connectionOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenAckPost(
      connectionId: string,
      connectionOpenAckRequestBody: ConnectionOpenAckReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling ibcConnectionsConnectionIdOpenAckPost.",
        );
      }
      // verify required parameter 'connectionOpenAckRequestBody' is not null or undefined
      if (
        connectionOpenAckRequestBody === null ||
        connectionOpenAckRequestBody === undefined
      ) {
        throw new RequiredError(
          "connectionOpenAckRequestBody",
          "Required parameter connectionOpenAckRequestBody was null or undefined when calling ibcConnectionsConnectionIdOpenAckPost.",
        );
      }
      const localVarPath = `/ibc/connections/{connection-id}/open-ack`.replace(
        `{${"connection-id"}}`,
        encodeURIComponent(String(connectionId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof connectionOpenAckRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            connectionOpenAckRequestBody !== undefined
              ? connectionOpenAckRequestBody
              : {},
          )
        : connectionOpenAckRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Connection open-confirm
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenConfirmReq} connectionOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenConfirmPost(
      connectionId: string,
      connectionOpenConfirmRequestBody: ConnectionOpenConfirmReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling ibcConnectionsConnectionIdOpenConfirmPost.",
        );
      }
      // verify required parameter 'connectionOpenConfirmRequestBody' is not null or undefined
      if (
        connectionOpenConfirmRequestBody === null ||
        connectionOpenConfirmRequestBody === undefined
      ) {
        throw new RequiredError(
          "connectionOpenConfirmRequestBody",
          "Required parameter connectionOpenConfirmRequestBody was null or undefined when calling ibcConnectionsConnectionIdOpenConfirmPost.",
        );
      }
      const localVarPath = `/ibc/connections/{connection-id}/open-confirm`.replace(
        `{${"connection-id"}}`,
        encodeURIComponent(String(connectionId)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof connectionOpenConfirmRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            connectionOpenConfirmRequestBody !== undefined
              ? connectionOpenConfirmRequestBody
              : {},
          )
        : connectionOpenConfirmRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Connection open-init
     * @param {ConnectionOpenInitReq} connectionOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenInitPost(
      connectionOpenInitRequestBody: ConnectionOpenInitReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'connectionOpenInitRequestBody' is not null or undefined
      if (
        connectionOpenInitRequestBody === null ||
        connectionOpenInitRequestBody === undefined
      ) {
        throw new RequiredError(
          "connectionOpenInitRequestBody",
          "Required parameter connectionOpenInitRequestBody was null or undefined when calling ibcConnectionsOpenInitPost.",
        );
      }
      const localVarPath = `/ibc/connections/open-init`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof connectionOpenInitRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            connectionOpenInitRequestBody !== undefined
              ? connectionOpenInitRequestBody
              : {},
          )
        : connectionOpenInitRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Connection open-try
     * @param {ConnectionOpenTryReq} connectionOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenTryPost(
      connectionOpenTryRequestBody: ConnectionOpenTryReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'connectionOpenTryRequestBody' is not null or undefined
      if (
        connectionOpenTryRequestBody === null ||
        connectionOpenTryRequestBody === undefined
      ) {
        throw new RequiredError(
          "connectionOpenTryRequestBody",
          "Required parameter connectionOpenTryRequestBody was null or undefined when calling ibcConnectionsOpenTryPost.",
        );
      }
      const localVarPath = `/ibc/connections/open-try`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof connectionOpenTryRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            connectionOpenTryRequestBody !== undefined
              ? connectionOpenTryRequestBody
              : {},
          )
        : connectionOpenTryRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcHeaderGet(options: any = {}): RequestArgs {
      const localVarPath = `/ibc/header`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query node consensus-state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcNodeStateGet(options: any = {}): RequestArgs {
      const localVarPath = `/ibc/node-state`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Receive packet
     * @param {ReceivedPacketReq} receivePacketRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPacketsReceivePost(
      receivePacketRequestBody: ReceivedPacketReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'receivePacketRequestBody' is not null or undefined
      if (
        receivePacketRequestBody === null ||
        receivePacketRequestBody === undefined
      ) {
        throw new RequiredError(
          "receivePacketRequestBody",
          "Required parameter receivePacketRequestBody was null or undefined when calling ibcPacketsReceivePost.",
        );
      }
      const localVarPath = `/ibc/packets/receive`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof receivePacketRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            receivePacketRequestBody !== undefined
              ? receivePacketRequestBody
              : {},
          )
        : receivePacketRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query IBC path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPathGet(options: any = {}): RequestArgs {
      const localVarPath = `/ibc/path`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Channel close-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseConfirmReq} channelCloseConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
      portId: string,
      channelId: string,
      channelCloseConfirmRequestBody: ChannelCloseConfirmReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseConfirmPost.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseConfirmPost.",
        );
      }
      // verify required parameter 'channelCloseConfirmRequestBody' is not null or undefined
      if (
        channelCloseConfirmRequestBody === null ||
        channelCloseConfirmRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelCloseConfirmRequestBody",
          "Required parameter channelCloseConfirmRequestBody was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseConfirmPost.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/close-confirm`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelCloseConfirmRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelCloseConfirmRequestBody !== undefined
              ? channelCloseConfirmRequestBody
              : {},
          )
        : channelCloseConfirmRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Channel close-init
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseInitReq} channelCloseInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseInitPost(
      portId: string,
      channelId: string,
      channelCloseInitRequestBody: ChannelCloseInitReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseInitPost.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseInitPost.",
        );
      }
      // verify required parameter 'channelCloseInitRequestBody' is not null or undefined
      if (
        channelCloseInitRequestBody === null ||
        channelCloseInitRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelCloseInitRequestBody",
          "Required parameter channelCloseInitRequestBody was null or undefined when calling ibcPortsPortIdChannelsChannelIdCloseInitPost.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/close-init`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelCloseInitRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelCloseInitRequestBody !== undefined
              ? channelCloseInitRequestBody
              : {},
          )
        : channelCloseInitRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query channel
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdGet(
      portId: string,
      channelId: string,
      prove?: boolean,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdGet.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdGet.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (prove !== undefined) {
        localVarQueryParameter["prove"] = prove;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query next sequence receive
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
      portId: string,
      channelId: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/next-sequence-recv`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Channel open-ack
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenAckReq} channelOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenAckPost(
      portId: string,
      channelId: string,
      channelOpenAckRequestBody: ChannelOpenAckReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenAckPost.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenAckPost.",
        );
      }
      // verify required parameter 'channelOpenAckRequestBody' is not null or undefined
      if (
        channelOpenAckRequestBody === null ||
        channelOpenAckRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelOpenAckRequestBody",
          "Required parameter channelOpenAckRequestBody was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenAckPost.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/open-ack`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelOpenAckRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelOpenAckRequestBody !== undefined
              ? channelOpenAckRequestBody
              : {},
          )
        : channelOpenAckRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Channel open-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenConfirmReq} channelOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
      portId: string,
      channelId: string,
      channelOpenConfirmRequestBody: ChannelOpenConfirmReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenConfirmPost.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenConfirmPost.",
        );
      }
      // verify required parameter 'channelOpenConfirmRequestBody' is not null or undefined
      if (
        channelOpenConfirmRequestBody === null ||
        channelOpenConfirmRequestBody === undefined
      ) {
        throw new RequiredError(
          "channelOpenConfirmRequestBody",
          "Required parameter channelOpenConfirmRequestBody was null or undefined when calling ibcPortsPortIdChannelsChannelIdOpenConfirmPost.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/open-confirm`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof channelOpenConfirmRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            channelOpenConfirmRequestBody !== undefined
              ? channelOpenConfirmRequestBody
              : {},
          )
        : channelOpenConfirmRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transfer token
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {TransferTokenReq} transferTokenRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdTransferPost(
      portId: string,
      channelId: string,
      transferTokenRequestBody: TransferTokenReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'portId' is not null or undefined
      if (portId === null || portId === undefined) {
        throw new RequiredError(
          "portId",
          "Required parameter portId was null or undefined when calling ibcPortsPortIdChannelsChannelIdTransferPost.",
        );
      }
      // verify required parameter 'channelId' is not null or undefined
      if (channelId === null || channelId === undefined) {
        throw new RequiredError(
          "channelId",
          "Required parameter channelId was null or undefined when calling ibcPortsPortIdChannelsChannelIdTransferPost.",
        );
      }
      // verify required parameter 'transferTokenRequestBody' is not null or undefined
      if (
        transferTokenRequestBody === null ||
        transferTokenRequestBody === undefined
      ) {
        throw new RequiredError(
          "transferTokenRequestBody",
          "Required parameter transferTokenRequestBody was null or undefined when calling ibcPortsPortIdChannelsChannelIdTransferPost.",
        );
      }
      const localVarPath = `/ibc/ports/{port-id}/channels/{channel-id}/transfer`
        .replace(`{${"port-id"}}`, encodeURIComponent(String(portId)))
        .replace(`{${"channel-id"}}`, encodeURIComponent(String(channelId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof transferTokenRequestBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            transferTokenRequestBody !== undefined
              ? transferTokenRequestBody
              : {},
          )
        : transferTokenRequestBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IBCApi - functional programming interface
 * @export
 */
export const IBCApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Channel open-init
     * @param {ChannelOpenInitReq} channelOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenInitPost(
      channelOpenInitRequestBody: ChannelOpenInitReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcChannelsOpenInitPost(channelOpenInitRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Channel open-try
     * @param {ChannelOpenTryReq} channelOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenTryPost(
      channelOpenTryRequestBody: ChannelOpenTryReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcChannelsOpenTryPost(channelOpenTryRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query client state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdClientStateGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse20010> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdClientStateGet(clientId, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query connections of a client
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConnectionsGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<ClientConnectionsResponse> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdConnectionsGet(clientId, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query cliet consensus-state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConsensusStateGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2009> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdConsensusStateGet(clientId, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Submit misbehaviour
     * @param {string} clientId Client ID
     * @param {SubmitMisbehaviourReq} submitMisbehaviourRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdMisbehaviourPost(
      clientId: string,
      submitMisbehaviourRequestBody: SubmitMisbehaviourReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdMisbehaviourPost(
        clientId,
        submitMisbehaviourRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query client root
     * @param {string} clientId Client ID
     * @param {number} height Root height
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdRootsHeightGet(
      clientId: string,
      height: number,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse20011> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdRootsHeightGet(clientId, height, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Update client
     * @param {string} clientId Client ID
     * @param {UpdateClientReq} updateClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdUpdatePost(
      clientId: string,
      updateClientRequestBody: UpdateClientReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsClientIdUpdatePost(
        clientId,
        updateClientRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Create client
     * @param {CreateClientReq} createClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsPost(
      createClientRequestBody: CreateClientReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcClientsPost(createClientRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query connection
     * @param {string} connectionId Connection ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdGet(
      connectionId: string,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<ConnectionResponse> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcConnectionsConnectionIdGet(connectionId, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Connection open-ack
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenAckReq} connectionOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenAckPost(
      connectionId: string,
      connectionOpenAckRequestBody: ConnectionOpenAckReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcConnectionsConnectionIdOpenAckPost(
        connectionId,
        connectionOpenAckRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Connection open-confirm
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenConfirmReq} connectionOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenConfirmPost(
      connectionId: string,
      connectionOpenConfirmRequestBody: ConnectionOpenConfirmReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcConnectionsConnectionIdOpenConfirmPost(
        connectionId,
        connectionOpenConfirmRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Connection open-init
     * @param {ConnectionOpenInitReq} connectionOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenInitPost(
      connectionOpenInitRequestBody: ConnectionOpenInitReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcConnectionsOpenInitPost(connectionOpenInitRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Connection open-try
     * @param {ConnectionOpenTryReq} connectionOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenTryPost(
      connectionOpenTryRequestBody: ConnectionOpenTryReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcConnectionsOpenTryPost(connectionOpenTryRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcHeaderGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Header> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcHeaderGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query node consensus-state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcNodeStateGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<ConsensusState> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcNodeStateGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Receive packet
     * @param {ReceivedPacketReq} receivePacketRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPacketsReceivePost(
      receivePacketRequestBody: ReceivedPacketReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPacketsReceivePost(receivePacketRequestBody, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query IBC path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPathGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPathGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Channel close-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseConfirmReq} channelCloseConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
      portId: string,
      channelId: string,
      channelCloseConfirmRequestBody: ChannelCloseConfirmReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
        portId,
        channelId,
        channelCloseConfirmRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Channel close-init
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseInitReq} channelCloseInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseInitPost(
      portId: string,
      channelId: string,
      channelCloseInitRequestBody: ChannelCloseInitReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdCloseInitPost(
        portId,
        channelId,
        channelCloseInitRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query channel
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdGet(
      portId: string,
      channelId: string,
      prove?: boolean,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<ChannelResponse> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdGet(portId, channelId, prove, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query next sequence receive
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
      portId: string,
      channelId: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
        portId,
        channelId,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Channel open-ack
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenAckReq} channelOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenAckPost(
      portId: string,
      channelId: string,
      channelOpenAckRequestBody: ChannelOpenAckReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdOpenAckPost(
        portId,
        channelId,
        channelOpenAckRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Channel open-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenConfirmReq} channelOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
      portId: string,
      channelId: string,
      channelOpenConfirmRequestBody: ChannelOpenConfirmReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
        portId,
        channelId,
        channelOpenConfirmRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Transfer token
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {TransferTokenReq} transferTokenRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdTransferPost(
      portId: string,
      channelId: string,
      transferTokenRequestBody: TransferTokenReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = IBCApiAxiosParamCreator(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdTransferPost(
        portId,
        channelId,
        transferTokenRequestBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * IBCApi - factory interface
 * @export
 */
export const IBCApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Channel open-init
     * @param {ChannelOpenInitReq} channelOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenInitPost(
      channelOpenInitRequestBody: ChannelOpenInitReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcChannelsOpenInitPost(
        channelOpenInitRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Channel open-try
     * @param {ChannelOpenTryReq} channelOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcChannelsOpenTryPost(
      channelOpenTryRequestBody: ChannelOpenTryReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcChannelsOpenTryPost(
        channelOpenTryRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query client state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdClientStateGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<InlineResponse20010> {
      return IBCApiFp(configuration).ibcClientsClientIdClientStateGet(
        clientId,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query connections of a client
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConnectionsGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<ClientConnectionsResponse> {
      return IBCApiFp(configuration).ibcClientsClientIdConnectionsGet(
        clientId,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query cliet consensus-state
     * @param {string} clientId Client ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdConsensusStateGet(
      clientId: string,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<InlineResponse2009> {
      return IBCApiFp(configuration).ibcClientsClientIdConsensusStateGet(
        clientId,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Submit misbehaviour
     * @param {string} clientId Client ID
     * @param {SubmitMisbehaviourReq} submitMisbehaviourRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdMisbehaviourPost(
      clientId: string,
      submitMisbehaviourRequestBody: SubmitMisbehaviourReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcClientsClientIdMisbehaviourPost(
        clientId,
        submitMisbehaviourRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query client root
     * @param {string} clientId Client ID
     * @param {number} height Root height
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdRootsHeightGet(
      clientId: string,
      height: number,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<InlineResponse20011> {
      return IBCApiFp(configuration).ibcClientsClientIdRootsHeightGet(
        clientId,
        height,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Update client
     * @param {string} clientId Client ID
     * @param {UpdateClientReq} updateClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsClientIdUpdatePost(
      clientId: string,
      updateClientRequestBody: UpdateClientReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcClientsClientIdUpdatePost(
        clientId,
        updateClientRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Create client
     * @param {CreateClientReq} createClientRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcClientsPost(
      createClientRequestBody: CreateClientReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcClientsPost(
        createClientRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query connection
     * @param {string} connectionId Connection ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdGet(
      connectionId: string,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<ConnectionResponse> {
      return IBCApiFp(configuration).ibcConnectionsConnectionIdGet(
        connectionId,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Connection open-ack
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenAckReq} connectionOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenAckPost(
      connectionId: string,
      connectionOpenAckRequestBody: ConnectionOpenAckReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcConnectionsConnectionIdOpenAckPost(
        connectionId,
        connectionOpenAckRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Connection open-confirm
     * @param {string} connectionId Connection ID
     * @param {ConnectionOpenConfirmReq} connectionOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsConnectionIdOpenConfirmPost(
      connectionId: string,
      connectionOpenConfirmRequestBody: ConnectionOpenConfirmReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcConnectionsConnectionIdOpenConfirmPost(
        connectionId,
        connectionOpenConfirmRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Connection open-init
     * @param {ConnectionOpenInitReq} connectionOpenInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenInitPost(
      connectionOpenInitRequestBody: ConnectionOpenInitReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcConnectionsOpenInitPost(
        connectionOpenInitRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Connection open-try
     * @param {ConnectionOpenTryReq} connectionOpenTryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcConnectionsOpenTryPost(
      connectionOpenTryRequestBody: ConnectionOpenTryReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcConnectionsOpenTryPost(
        connectionOpenTryRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcHeaderGet(options?: any): AxiosPromise<Header> {
      return IBCApiFp(configuration).ibcHeaderGet(options)(axios, basePath);
    },
    /**
     *
     * @summary Query node consensus-state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcNodeStateGet(options?: any): AxiosPromise<ConsensusState> {
      return IBCApiFp(configuration).ibcNodeStateGet(options)(axios, basePath);
    },
    /**
     *
     * @summary Receive packet
     * @param {ReceivedPacketReq} receivePacketRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPacketsReceivePost(
      receivePacketRequestBody: ReceivedPacketReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcPacketsReceivePost(
        receivePacketRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query IBC path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPathGet(options?: any): AxiosPromise<string> {
      return IBCApiFp(configuration).ibcPathGet(options)(axios, basePath);
    },
    /**
     *
     * @summary Channel close-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseConfirmReq} channelCloseConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
      portId: string,
      channelId: string,
      channelCloseConfirmRequestBody: ChannelCloseConfirmReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
        portId,
        channelId,
        channelCloseConfirmRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Channel close-init
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelCloseInitReq} channelCloseInitRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdCloseInitPost(
      portId: string,
      channelId: string,
      channelCloseInitRequestBody: ChannelCloseInitReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdCloseInitPost(
        portId,
        channelId,
        channelCloseInitRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query channel
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {boolean} [prove] Proof of result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdGet(
      portId: string,
      channelId: string,
      prove?: boolean,
      options?: any,
    ): AxiosPromise<ChannelResponse> {
      return IBCApiFp(configuration).ibcPortsPortIdChannelsChannelIdGet(
        portId,
        channelId,
        prove,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query next sequence receive
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
      portId: string,
      channelId: string,
      options?: any,
    ): AxiosPromise<number> {
      return IBCApiFp(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
        portId,
        channelId,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Channel open-ack
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenAckReq} channelOpenAckRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenAckPost(
      portId: string,
      channelId: string,
      channelOpenAckRequestBody: ChannelOpenAckReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(configuration).ibcPortsPortIdChannelsChannelIdOpenAckPost(
        portId,
        channelId,
        channelOpenAckRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Channel open-confirm
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {ChannelOpenConfirmReq} channelOpenConfirmRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
      portId: string,
      channelId: string,
      channelOpenConfirmRequestBody: ChannelOpenConfirmReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
        portId,
        channelId,
        channelOpenConfirmRequestBody,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Transfer token
     * @param {string} portId Port ID
     * @param {string} channelId Channel ID
     * @param {TransferTokenReq} transferTokenRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcPortsPortIdChannelsChannelIdTransferPost(
      portId: string,
      channelId: string,
      transferTokenRequestBody: TransferTokenReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return IBCApiFp(
        configuration,
      ).ibcPortsPortIdChannelsChannelIdTransferPost(
        portId,
        channelId,
        transferTokenRequestBody,
        options,
      )(axios, basePath);
    },
  };
};

/**
 * IBCApi - object-oriented interface
 * @export
 * @class IBCApi
 * @extends {BaseAPI}
 */
export class IBCApi extends BaseAPI {
  /**
   *
   * @summary Channel open-init
   * @param {ChannelOpenInitReq} channelOpenInitRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcChannelsOpenInitPost(
    channelOpenInitRequestBody: ChannelOpenInitReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcChannelsOpenInitPost(
      channelOpenInitRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Channel open-try
   * @param {ChannelOpenTryReq} channelOpenTryRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcChannelsOpenTryPost(
    channelOpenTryRequestBody: ChannelOpenTryReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcChannelsOpenTryPost(
      channelOpenTryRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query client state
   * @param {string} clientId Client ID
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdClientStateGet(
    clientId: string,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdClientStateGet(
      clientId,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query connections of a client
   * @param {string} clientId Client ID
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdConnectionsGet(
    clientId: string,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdConnectionsGet(
      clientId,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query cliet consensus-state
   * @param {string} clientId Client ID
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdConsensusStateGet(
    clientId: string,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdConsensusStateGet(
      clientId,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Submit misbehaviour
   * @param {string} clientId Client ID
   * @param {SubmitMisbehaviourReq} submitMisbehaviourRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdMisbehaviourPost(
    clientId: string,
    submitMisbehaviourRequestBody: SubmitMisbehaviourReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdMisbehaviourPost(
      clientId,
      submitMisbehaviourRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query client root
   * @param {string} clientId Client ID
   * @param {number} height Root height
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdRootsHeightGet(
    clientId: string,
    height: number,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdRootsHeightGet(
      clientId,
      height,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Update client
   * @param {string} clientId Client ID
   * @param {UpdateClientReq} updateClientRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsClientIdUpdatePost(
    clientId: string,
    updateClientRequestBody: UpdateClientReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsClientIdUpdatePost(
      clientId,
      updateClientRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Create client
   * @param {CreateClientReq} createClientRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcClientsPost(
    createClientRequestBody: CreateClientReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcClientsPost(
      createClientRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query connection
   * @param {string} connectionId Connection ID
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcConnectionsConnectionIdGet(
    connectionId: string,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcConnectionsConnectionIdGet(
      connectionId,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Connection open-ack
   * @param {string} connectionId Connection ID
   * @param {ConnectionOpenAckReq} connectionOpenAckRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcConnectionsConnectionIdOpenAckPost(
    connectionId: string,
    connectionOpenAckRequestBody: ConnectionOpenAckReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcConnectionsConnectionIdOpenAckPost(
      connectionId,
      connectionOpenAckRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Connection open-confirm
   * @param {string} connectionId Connection ID
   * @param {ConnectionOpenConfirmReq} connectionOpenConfirmRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcConnectionsConnectionIdOpenConfirmPost(
    connectionId: string,
    connectionOpenConfirmRequestBody: ConnectionOpenConfirmReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcConnectionsConnectionIdOpenConfirmPost(
      connectionId,
      connectionOpenConfirmRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Connection open-init
   * @param {ConnectionOpenInitReq} connectionOpenInitRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcConnectionsOpenInitPost(
    connectionOpenInitRequestBody: ConnectionOpenInitReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcConnectionsOpenInitPost(
      connectionOpenInitRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Connection open-try
   * @param {ConnectionOpenTryReq} connectionOpenTryRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcConnectionsOpenTryPost(
    connectionOpenTryRequestBody: ConnectionOpenTryReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcConnectionsOpenTryPost(
      connectionOpenTryRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcHeaderGet(options?: any) {
    return IBCApiFp(this.configuration).ibcHeaderGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Query node consensus-state
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcNodeStateGet(options?: any) {
    return IBCApiFp(this.configuration).ibcNodeStateGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Receive packet
   * @param {ReceivedPacketReq} receivePacketRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPacketsReceivePost(
    receivePacketRequestBody: ReceivedPacketReq,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcPacketsReceivePost(
      receivePacketRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query IBC path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPathGet(options?: any) {
    return IBCApiFp(this.configuration).ibcPathGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Channel close-confirm
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {ChannelCloseConfirmReq} channelCloseConfirmRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
    portId: string,
    channelId: string,
    channelCloseConfirmRequestBody: ChannelCloseConfirmReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdCloseConfirmPost(
      portId,
      channelId,
      channelCloseConfirmRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Channel close-init
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {ChannelCloseInitReq} channelCloseInitRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdCloseInitPost(
    portId: string,
    channelId: string,
    channelCloseInitRequestBody: ChannelCloseInitReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdCloseInitPost(
      portId,
      channelId,
      channelCloseInitRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query channel
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {boolean} [prove] Proof of result
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdGet(
    portId: string,
    channelId: string,
    prove?: boolean,
    options?: any,
  ) {
    return IBCApiFp(this.configuration).ibcPortsPortIdChannelsChannelIdGet(
      portId,
      channelId,
      prove,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query next sequence receive
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
    portId: string,
    channelId: string,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdNextSequenceRecvGet(
      portId,
      channelId,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Channel open-ack
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {ChannelOpenAckReq} channelOpenAckRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdOpenAckPost(
    portId: string,
    channelId: string,
    channelOpenAckRequestBody: ChannelOpenAckReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdOpenAckPost(
      portId,
      channelId,
      channelOpenAckRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Channel open-confirm
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {ChannelOpenConfirmReq} channelOpenConfirmRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
    portId: string,
    channelId: string,
    channelOpenConfirmRequestBody: ChannelOpenConfirmReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdOpenConfirmPost(
      portId,
      channelId,
      channelOpenConfirmRequestBody,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Transfer token
   * @param {string} portId Port ID
   * @param {string} channelId Channel ID
   * @param {TransferTokenReq} transferTokenRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCApi
   */
  public ibcPortsPortIdChannelsChannelIdTransferPost(
    portId: string,
    channelId: string,
    transferTokenRequestBody: TransferTokenReq,
    options?: any,
  ) {
    return IBCApiFp(
      this.configuration,
    ).ibcPortsPortIdChannelsChannelIdTransferPost(
      portId,
      channelId,
      transferTokenRequestBody,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * MintApi - axios parameter creator
 * @export
 */
export const MintApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingAnnualProvisionsGet(options: any = {}): RequestArgs {
      const localVarPath = `/minting/annual-provisions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingInflationGet(options: any = {}): RequestArgs {
      const localVarPath = `/minting/inflation`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingParametersGet(options: any = {}): RequestArgs {
      const localVarPath = `/minting/parameters`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MintApi - functional programming interface
 * @export
 */
export const MintApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingAnnualProvisionsGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = MintApiAxiosParamCreator(
        configuration,
      ).mintingAnnualProvisionsGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingInflationGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = MintApiAxiosParamCreator(
        configuration,
      ).mintingInflationGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingParametersGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = MintApiAxiosParamCreator(
        configuration,
      ).mintingParametersGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * MintApi - factory interface
 * @export
 */
export const MintApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingAnnualProvisionsGet(options?: any): AxiosPromise<string> {
      return MintApiFp(configuration).mintingAnnualProvisionsGet(options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingInflationGet(options?: any): AxiosPromise<string> {
      return MintApiFp(configuration).mintingInflationGet(options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintingParametersGet(options?: any): AxiosPromise<object> {
      return MintApiFp(configuration).mintingParametersGet(options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
export class MintApi extends BaseAPI {
  /**
   *
   * @summary Current minting annual provisions value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MintApi
   */
  public mintingAnnualProvisionsGet(options?: any) {
    return MintApiFp(this.configuration).mintingAnnualProvisionsGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Current minting inflation value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MintApi
   */
  public mintingInflationGet(options?: any) {
    return MintApiFp(this.configuration).mintingInflationGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Minting module parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MintApi
   */
  public mintingParametersGet(options?: any) {
    return MintApiFp(this.configuration).mintingParametersGet(options)(
      this.axios,
      this.basePath,
    );
  }
}

/**
 * SlashingApi - axios parameter creator
 * @export
 */
export const SlashingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingParametersGet(options: any = {}): RequestArgs {
      const localVarPath = `/slashing/parameters`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingSigningInfosGet(
      page: number,
      limit: number,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'page' is not null or undefined
      if (page === null || page === undefined) {
        throw new RequiredError(
          "page",
          "Required parameter page was null or undefined when calling slashingSigningInfosGet.",
        );
      }
      // verify required parameter 'limit' is not null or undefined
      if (limit === null || limit === undefined) {
        throw new RequiredError(
          "limit",
          "Required parameter limit was null or undefined when calling slashingSigningInfosGet.",
        );
      }
      const localVarPath = `/slashing/signing_infos`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {UnjailReq} unjailBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingValidatorsValidatorAddrUnjailPost(
      validatorAddr: string,
      unjailBody: UnjailReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.",
        );
      }
      // verify required parameter 'unjailBody' is not null or undefined
      if (unjailBody === null || unjailBody === undefined) {
        throw new RequiredError(
          "unjailBody",
          "Required parameter unjailBody was null or undefined when calling slashingValidatorsValidatorAddrUnjailPost.",
        );
      }
      const localVarPath = `/slashing/validators/{validatorAddr}/unjail`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof unjailBody !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(unjailBody !== undefined ? unjailBody : {})
        : unjailBody || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SlashingApi - functional programming interface
 * @export
 */
export const SlashingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingParametersGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2007> {
      const localVarAxiosArgs = SlashingApiAxiosParamCreator(
        configuration,
      ).slashingParametersGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingSigningInfosGet(
      page: number,
      limit: number,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<SigningInfo>> {
      const localVarAxiosArgs = SlashingApiAxiosParamCreator(
        configuration,
      ).slashingSigningInfosGet(page, limit, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {UnjailReq} unjailBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingValidatorsValidatorAddrUnjailPost(
      validatorAddr: string,
      unjailBody: UnjailReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = SlashingApiAxiosParamCreator(
        configuration,
      ).slashingValidatorsValidatorAddrUnjailPost(
        validatorAddr,
        unjailBody,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SlashingApi - factory interface
 * @export
 */
export const SlashingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingParametersGet(options?: any): AxiosPromise<InlineResponse2007> {
      return SlashingApiFp(configuration).slashingParametersGet(options)(
        axios,
        basePath,
      );
    },
    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingSigningInfosGet(
      page: number,
      limit: number,
      options?: any,
    ): AxiosPromise<Array<SigningInfo>> {
      return SlashingApiFp(configuration).slashingSigningInfosGet(
        page,
        limit,
        options,
      )(axios, basePath);
    },
    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {UnjailReq} unjailBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slashingValidatorsValidatorAddrUnjailPost(
      validatorAddr: string,
      unjailBody: UnjailReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return SlashingApiFp(
        configuration,
      ).slashingValidatorsValidatorAddrUnjailPost(
        validatorAddr,
        unjailBody,
        options,
      )(axios, basePath);
    },
  };
};

/**
 * SlashingApi - object-oriented interface
 * @export
 * @class SlashingApi
 * @extends {BaseAPI}
 */
export class SlashingApi extends BaseAPI {
  /**
   *
   * @summary Get the current slashing parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlashingApi
   */
  public slashingParametersGet(options?: any) {
    return SlashingApiFp(this.configuration).slashingParametersGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Get sign info of all validators
   * @summary Get sign info of given all validators
   * @param {number} page Page number
   * @param {number} limit Maximum number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlashingApi
   */
  public slashingSigningInfosGet(page: number, limit: number, options?: any) {
    return SlashingApiFp(this.configuration).slashingSigningInfosGet(
      page,
      limit,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Send transaction to unjail a jailed validator
   * @summary Unjail a jailed validator
   * @param {string} validatorAddr Bech32 validator address
   * @param {UnjailReq} unjailBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlashingApi
   */
  public slashingValidatorsValidatorAddrUnjailPost(
    validatorAddr: string,
    unjailBody: UnjailReq,
    options?: any,
  ) {
    return SlashingApiFp(
      this.configuration,
    ).slashingValidatorsValidatorAddrUnjailPost(
      validatorAddr,
      unjailBody,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsGet(
      delegatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {DelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsPost(
      delegatorAddr: string,
      delegation?: DelegateReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsPost.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof delegation !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(delegation !== undefined ? delegation : {})
        : delegation || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.",
        );
      }
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}`
        .replace(
          `{${"delegatorAddr"}}`,
          encodeURIComponent(String(delegatorAddr)),
        )
        .replace(
          `{${"validatorAddr"}}`,
          encodeURIComponent(String(validatorAddr)),
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {RedelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrRedelegationsPost(
      delegatorAddr: string,
      delegation?: RedelegateReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrRedelegationsPost.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/redelegations`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof delegation !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(delegation !== undefined ? delegation : {})
        : delegation || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
      delegatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {UndelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
      delegatorAddr: string,
      delegation?: UndelegateReq,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsPost.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof delegation !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(delegation !== undefined ? delegation : {})
        : delegation || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.",
        );
      }
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}`
        .replace(
          `{${"delegatorAddr"}}`,
          encodeURIComponent(String(delegatorAddr)),
        )
        .replace(
          `{${"validatorAddr"}}`,
          encodeURIComponent(String(validatorAddr)),
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsGet(
      delegatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/validators`.replace(
        `{${"delegatorAddr"}}`,
        encodeURIComponent(String(delegatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'delegatorAddr' is not null or undefined
      if (delegatorAddr === null || delegatorAddr === undefined) {
        throw new RequiredError(
          "delegatorAddr",
          "Required parameter delegatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.",
        );
      }
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet.",
        );
      }
      const localVarPath = `/staking/delegators/{delegatorAddr}/validators/{validatorAddr}`
        .replace(
          `{${"delegatorAddr"}}`,
          encodeURIComponent(String(delegatorAddr)),
        )
        .replace(
          `{${"validatorAddr"}}`,
          encodeURIComponent(String(validatorAddr)),
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingParametersGet(options: any = {}): RequestArgs {
      const localVarPath = `/staking/parameters`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolGet(options: any = {}): RequestArgs {
      const localVarPath = `/staking/pool`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingRedelegationsGet(
      delegator?: string,
      validatorFrom?: string,
      validatorTo?: string,
      options: any = {},
    ): RequestArgs {
      const localVarPath = `/staking/redelegations`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (delegator !== undefined) {
        localVarQueryParameter["delegator"] = delegator;
      }

      if (validatorFrom !== undefined) {
        localVarQueryParameter["validator_from"] = validatorFrom;
      }

      if (validatorTo !== undefined) {
        localVarQueryParameter["validator_to"] = validatorTo;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsGet(
      status?: string,
      page?: number,
      limit?: number,
      options: any = {},
    ): RequestArgs {
      const localVarPath = `/staking/validators`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrDelegationsGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrDelegationsGet.",
        );
      }
      const localVarPath = `/staking/validators/{validatorAddr}/delegations`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrGet.",
        );
      }
      const localVarPath = `/staking/validators/{validatorAddr}`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrUnbondingDelegationsGet(
      validatorAddr: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'validatorAddr' is not null or undefined
      if (validatorAddr === null || validatorAddr === undefined) {
        throw new RequiredError(
          "validatorAddr",
          "Required parameter validatorAddr was null or undefined when calling stakingValidatorsValidatorAddrUnbondingDelegationsGet.",
        );
      }
      const localVarPath = `/staking/validators/{validatorAddr}/unbonding_delegations`.replace(
        `{${"validatorAddr"}}`,
        encodeURIComponent(String(validatorAddr)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsGet(
      delegatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Delegation>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {DelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsPost(
      delegatorAddr: string,
      delegation?: DelegateReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsPost(
        delegatorAddr,
        delegation,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Delegation> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {RedelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrRedelegationsPost(
      delegatorAddr: string,
      delegation?: RedelegateReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrRedelegationsPost(
        delegatorAddr,
        delegation,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
      delegatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<UnbondingDelegation>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
        delegatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {UndelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
      delegatorAddr: string,
      delegation?: UndelegateReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
        delegatorAddr,
        delegation,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<UnbondingDelegationPair> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsGet(
      delegatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Validator>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingParametersGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2006> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingParametersGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2005> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingPoolGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingRedelegationsGet(
      delegator?: string,
      validatorFrom?: string,
      validatorTo?: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Redelegation>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsGet(
      status?: string,
      page?: number,
      limit?: number,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Validator>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingValidatorsGet(status, page, limit, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrDelegationsGet(
      validatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<Delegation>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrGet(
      validatorAddr: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingValidatorsValidatorAddrGet(validatorAddr, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrUnbondingDelegationsGet(
      validatorAddr: string,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<Array<UnbondingDelegation>> {
      const localVarAxiosArgs = StakingApiAxiosParamCreator(
        configuration,
      ).stakingValidatorsValidatorAddrUnbondingDelegationsGet(
        validatorAddr,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsGet(
      delegatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Delegation>> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {DelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsPost(
      delegatorAddr: string,
      delegation?: DelegateReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsPost(
        delegatorAddr,
        delegation,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Delegation> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {RedelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrRedelegationsPost(
      delegatorAddr: string,
      delegation?: RedelegateReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrRedelegationsPost(
        delegatorAddr,
        delegation,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
      delegatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<UnbondingDelegation>> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
        delegatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {UndelegateReq} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
      delegatorAddr: string,
      delegation?: UndelegateReq,
      options?: any,
    ): AxiosPromise<StdTx> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
        delegatorAddr,
        delegation,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<UnbondingDelegationPair> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsGet(
      delegatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Validator>> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
      delegatorAddr: string,
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Validator> {
      return StakingApiFp(
        configuration,
      ).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
        delegatorAddr,
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingParametersGet(options?: any): AxiosPromise<InlineResponse2006> {
      return StakingApiFp(configuration).stakingParametersGet(options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolGet(options?: any): AxiosPromise<InlineResponse2005> {
      return StakingApiFp(configuration).stakingPoolGet(options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingRedelegationsGet(
      delegator?: string,
      validatorFrom?: string,
      validatorTo?: string,
      options?: any,
    ): AxiosPromise<Array<Redelegation>> {
      return StakingApiFp(configuration).stakingRedelegationsGet(
        delegator,
        validatorFrom,
        validatorTo,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsGet(
      status?: string,
      page?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<Array<Validator>> {
      return StakingApiFp(configuration).stakingValidatorsGet(
        status,
        page,
        limit,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrDelegationsGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<Delegation>> {
      return StakingApiFp(
        configuration,
      ).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Validator> {
      return StakingApiFp(configuration).stakingValidatorsValidatorAddrGet(
        validatorAddr,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingValidatorsValidatorAddrUnbondingDelegationsGet(
      validatorAddr: string,
      options?: any,
    ): AxiosPromise<Array<UnbondingDelegation>> {
      return StakingApiFp(
        configuration,
      ).stakingValidatorsValidatorAddrUnbondingDelegationsGet(
        validatorAddr,
        options,
      )(axios, basePath);
    },
  };
};

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
  /**
   *
   * @summary Get all delegations from a delegator
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrDelegationsGet(
    delegatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Submit delegation
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {DelegateReq} [delegation]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrDelegationsPost(
    delegatorAddr: string,
    delegation?: DelegateReq,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrDelegationsPost(
      delegatorAddr,
      delegation,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query the current delegation between a delegator and a validator
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
    delegatorAddr: string,
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(
      delegatorAddr,
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Submit a redelegation
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {RedelegationReq} [delegation]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrRedelegationsPost(
    delegatorAddr: string,
    delegation?: RedelegateReq,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrRedelegationsPost(
      delegatorAddr,
      delegation,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get all unbonding delegations from a delegator
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
    delegatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(
      delegatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Submit an unbonding delegation
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {UndelegateReq} [delegation]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
    delegatorAddr: string,
    delegation?: UndelegateReq,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(
      delegatorAddr,
      delegation,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query all unbonding delegations between a delegator and a validator
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
    delegatorAddr: string,
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(
      delegatorAddr,
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Query all validators that a delegator is bonded to
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrValidatorsGet(
    delegatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Query a validator that a delegator is bonded to
   * @param {string} delegatorAddr Bech32 AccAddress of Delegator
   * @param {string} validatorAddr Bech32 ValAddress of Delegator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
    delegatorAddr: string,
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(
      delegatorAddr,
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get the current staking parameter values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingParametersGet(options?: any) {
    return StakingApiFp(this.configuration).stakingParametersGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get the current state of the staking pool
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingPoolGet(options?: any) {
    return StakingApiFp(this.configuration).stakingPoolGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get all redelegations (filter by query params)
   * @param {string} [delegator] Bech32 AccAddress of Delegator
   * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
   * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingRedelegationsGet(
    delegator?: string,
    validatorFrom?: string,
    validatorTo?: string,
    options?: any,
  ) {
    return StakingApiFp(this.configuration).stakingRedelegationsGet(
      delegator,
      validatorFrom,
      validatorTo,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get all validator candidates. By default it returns only the bonded validators.
   * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
   * @param {number} [page] The page number.
   * @param {number} [limit] The maximum number of items per page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingValidatorsGet(
    status?: string,
    page?: number,
    limit?: number,
    options?: any,
  ) {
    return StakingApiFp(this.configuration).stakingValidatorsGet(
      status,
      page,
      limit,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get all delegations from a validator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingValidatorsValidatorAddrDelegationsGet(
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Query the information from a single validator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingValidatorsValidatorAddrGet(
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrGet(
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get all unbonding delegations from a validator
   * @param {string} validatorAddr Bech32 OperatorAddress of validator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingValidatorsValidatorAddrUnbondingDelegationsGet(
    validatorAddr: string,
    options?: any,
  ) {
    return StakingApiFp(
      this.configuration,
    ).stakingValidatorsValidatorAddrUnbondingDelegationsGet(
      validatorAddr,
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * SupplyApi - axios parameter creator
 * @export
 */
export const SupplyApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalDenominationGet(
      denomination: string,
      options: any = {},
    ): RequestArgs {
      // verify required parameter 'denomination' is not null or undefined
      if (denomination === null || denomination === undefined) {
        throw new RequiredError(
          "denomination",
          "Required parameter denomination was null or undefined when calling supplyTotalDenominationGet.",
        );
      }
      const localVarPath = `/supply/total/{denomination}`.replace(
        `{${"denomination"}}`,
        encodeURIComponent(String(denomination)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalGet(options: any = {}): RequestArgs {
      const localVarPath = `/supply/total`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SupplyApi - functional programming interface
 * @export
 */
export const SupplyApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalDenominationGet(
      denomination: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
      const localVarAxiosArgs = SupplyApiAxiosParamCreator(
        configuration,
      ).supplyTotalDenominationGet(denomination, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supply> {
      const localVarAxiosArgs = SupplyApiAxiosParamCreator(
        configuration,
      ).supplyTotalGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SupplyApi - factory interface
 * @export
 */
export const SupplyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalDenominationGet(
      denomination: string,
      options?: any,
    ): AxiosPromise<string> {
      return SupplyApiFp(configuration).supplyTotalDenominationGet(
        denomination,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyTotalGet(options?: any): AxiosPromise<Supply> {
      return SupplyApiFp(configuration).supplyTotalGet(options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * SupplyApi - object-oriented interface
 * @export
 * @class SupplyApi
 * @extends {BaseAPI}
 */
export class SupplyApi extends BaseAPI {
  /**
   *
   * @summary Total supply of a single coin denomination
   * @param {string} denomination Coin denomination
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupplyApi
   */
  public supplyTotalDenominationGet(denomination: string, options?: any) {
    return SupplyApiFp(this.configuration).supplyTotalDenominationGet(
      denomination,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Total supply of coins in the chain
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupplyApi
   */
  public supplyTotalGet(options?: any) {
    return SupplyApiFp(this.configuration).supplyTotalGet(options)(
      this.axios,
      this.basePath,
    );
  }
}

/**
 * TendermintRPCApi - axios parameter creator
 * @export
 */
export const TendermintRPCApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksHeightGet(height: number, options: any = {}): RequestArgs {
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling blocksHeightGet.",
        );
      }
      const localVarPath = `/blocks/{height}`.replace(
        `{${"height"}}`,
        encodeURIComponent(String(height)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksLatestGet(options: any = {}): RequestArgs {
      const localVarPath = `/blocks/latest`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncingGet(options: any = {}): RequestArgs {
      const localVarPath = `/syncing`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsHeightGet(height: number, options: any = {}): RequestArgs {
      // verify required parameter 'height' is not null or undefined
      if (height === null || height === undefined) {
        throw new RequiredError(
          "height",
          "Required parameter height was null or undefined when calling validatorsetsHeightGet.",
        );
      }
      const localVarPath = `/validatorsets/{height}`.replace(
        `{${"height"}}`,
        encodeURIComponent(String(height)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsLatestGet(options: any = {}): RequestArgs {
      const localVarPath = `/validatorsets/latest`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TendermintRPCApi - functional programming interface
 * @export
 */
export const TendermintRPCApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksHeightGet(
      height: number,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockQuery> {
      const localVarAxiosArgs = TendermintRPCApiAxiosParamCreator(
        configuration,
      ).blocksHeightGet(height, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksLatestGet(
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockQuery> {
      const localVarAxiosArgs = TendermintRPCApiAxiosParamCreator(
        configuration,
      ).blocksLatestGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncingGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2001> {
      const localVarAxiosArgs = TendermintRPCApiAxiosParamCreator(
        configuration,
      ).syncingGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsHeightGet(
      height: number,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2002> {
      const localVarAxiosArgs = TendermintRPCApiAxiosParamCreator(
        configuration,
      ).validatorsetsHeightGet(height, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsLatestGet(
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2002> {
      const localVarAxiosArgs = TendermintRPCApiAxiosParamCreator(
        configuration,
      ).validatorsetsLatestGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TendermintRPCApi - factory interface
 * @export
 */
export const TendermintRPCApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksHeightGet(height: number, options?: any): AxiosPromise<BlockQuery> {
      return TendermintRPCApiFp(configuration).blocksHeightGet(height, options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blocksLatestGet(options?: any): AxiosPromise<BlockQuery> {
      return TendermintRPCApiFp(configuration).blocksLatestGet(options)(
        axios,
        basePath,
      );
    },
    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncingGet(options?: any): AxiosPromise<InlineResponse2001> {
      return TendermintRPCApiFp(configuration).syncingGet(options)(
        axios,
        basePath,
      );
    },
    /**
     *
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsHeightGet(
      height: number,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return TendermintRPCApiFp(configuration).validatorsetsHeightGet(
        height,
        options,
      )(axios, basePath);
    },
    /**
     *
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatorsetsLatestGet(options?: any): AxiosPromise<InlineResponse2002> {
      return TendermintRPCApiFp(configuration).validatorsetsLatestGet(options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * TendermintRPCApi - object-oriented interface
 * @export
 * @class TendermintRPCApi
 * @extends {BaseAPI}
 */
export class TendermintRPCApi extends BaseAPI {
  /**
   *
   * @summary Get a block at a certain height
   * @param {number} height Block height
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TendermintRPCApi
   */
  public blocksHeightGet(height: number, options?: any) {
    return TendermintRPCApiFp(this.configuration).blocksHeightGet(
      height,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get the latest block
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TendermintRPCApi
   */
  public blocksLatestGet(options?: any) {
    return TendermintRPCApiFp(this.configuration).blocksLatestGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Get if the node is currently syning with other nodes
   * @summary Syncing state of node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TendermintRPCApi
   */
  public syncingGet(options?: any) {
    return TendermintRPCApiFp(this.configuration).syncingGet(options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get a validator set a certain height
   * @param {number} height Block height
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TendermintRPCApi
   */
  public validatorsetsHeightGet(height: number, options?: any) {
    return TendermintRPCApiFp(this.configuration).validatorsetsHeightGet(
      height,
      options,
    )(this.axios, this.basePath);
  }

  /**
   *
   * @summary Get the latest validator set
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TendermintRPCApi
   */
  public validatorsetsLatestGet(options?: any) {
    return TendermintRPCApiFp(this.configuration).validatorsetsLatestGet(
      options,
    )(this.axios, this.basePath);
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {DecodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsDecodePost(tx: DecodeReq, options: any = {}): RequestArgs {
      // verify required parameter 'tx' is not null or undefined
      if (tx === null || tx === undefined) {
        throw new RequiredError(
          "tx",
          "Required parameter tx was null or undefined when calling txsDecodePost.",
        );
      }
      const localVarPath = `/txs/decode`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof tx !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(tx !== undefined ? tx : {})
        : tx || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {EncodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsEncodePost(tx: EncodeReq, options: any = {}): RequestArgs {
      // verify required parameter 'tx' is not null or undefined
      if (tx === null || tx === undefined) {
        throw new RequiredError(
          "tx",
          "Required parameter tx was null or undefined when calling txsEncodePost.",
        );
      }
      const localVarPath = `/txs/encode`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof tx !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(tx !== undefined ? tx : {})
        : tx || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsGet(
      messageAction?: string,
      messageSender?: string,
      page?: number,
      limit?: number,
      txMinheight?: number,
      txMaxheight?: number,
      options: any = {},
    ): RequestArgs {
      const localVarPath = `/txs`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (messageAction !== undefined) {
        localVarQueryParameter["message.action"] = messageAction;
      }

      if (messageSender !== undefined) {
        localVarQueryParameter["message.sender"] = messageSender;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (txMinheight !== undefined) {
        localVarQueryParameter["tx.minheight"] = txMinheight;
      }

      if (txMaxheight !== undefined) {
        localVarQueryParameter["tx.maxheight"] = txMaxheight;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsHashGet(hash: string, options: any = {}): RequestArgs {
      // verify required parameter 'hash' is not null or undefined
      if (hash === null || hash === undefined) {
        throw new RequiredError(
          "hash",
          "Required parameter hash was null or undefined when calling txsHashGet.",
        );
      }
      const localVarPath = `/txs/{hash}`.replace(
        `{${"hash"}}`,
        encodeURIComponent(String(hash)),
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {BroadcastReq} txBroadcast
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsPost(txBroadcast: BroadcastReq, options: any = {}): RequestArgs {
      // verify required parameter 'txBroadcast' is not null or undefined
      if (txBroadcast === null || txBroadcast === undefined) {
        throw new RequiredError(
          "txBroadcast",
          "Required parameter txBroadcast was null or undefined when calling txsPost.",
        );
      }
      const localVarPath = `/txs`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof txBroadcast !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(txBroadcast !== undefined ? txBroadcast : {})
        : txBroadcast || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {DecodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsDecodePost(
      tx: DecodeReq,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StdTx> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration,
      ).txsDecodePost(tx, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {EncodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsEncodePost(
      tx: EncodeReq,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<InlineResponse2003> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration,
      ).txsEncodePost(tx, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsGet(
      messageAction?: string,
      messageSender?: string,
      page?: number,
      limit?: number,
      txMinheight?: number,
      txMaxheight?: number,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<PaginatedQueryTxs> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration,
      ).txsGet(
        messageAction,
        messageSender,
        page,
        limit,
        txMinheight,
        txMaxheight,
        options,
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsHashGet(
      hash: string,
      options?: any,
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxQuery> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration,
      ).txsHashGet(hash, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {BroadcastReq} txBroadcast
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsPost(
      txBroadcast: BroadcastReq,
      options?: any,
    ): (
      axios?: AxiosInstance,
      basePath?: string,
    ) => AxiosPromise<BroadcastTxCommitResult> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration,
      ).txsPost(txBroadcast, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {DecodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsDecodePost(tx: DecodeReq, options?: any): AxiosPromise<StdTx> {
      return TransactionsApiFp(configuration).txsDecodePost(tx, options)(
        axios,
        basePath,
      );
    },
    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {EncodeReq} tx
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsEncodePost(
      tx: EncodeReq,
      options?: any,
    ): AxiosPromise<InlineResponse2003> {
      return TransactionsApiFp(configuration).txsEncodePost(tx, options)(
        axios,
        basePath,
      );
    },
    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsGet(
      messageAction?: string,
      messageSender?: string,
      page?: number,
      limit?: number,
      txMinheight?: number,
      txMaxheight?: number,
      options?: any,
    ): AxiosPromise<PaginatedQueryTxs> {
      return TransactionsApiFp(configuration).txsGet(
        messageAction,
        messageSender,
        page,
        limit,
        txMinheight,
        txMaxheight,
        options,
      )(axios, basePath);
    },
    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsHashGet(hash: string, options?: any): AxiosPromise<TxQuery> {
      return TransactionsApiFp(configuration).txsHashGet(hash, options)(
        axios,
        basePath,
      );
    },
    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {BroadcastReq} txBroadcast
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    txsPost(
      txBroadcast: BroadcastReq,
      options?: any,
    ): AxiosPromise<BroadcastTxCommitResult> {
      return TransactionsApiFp(configuration).txsPost(txBroadcast, options)(
        axios,
        basePath,
      );
    },
  };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
   * @summary Decode a transaction from the Amino wire format
   * @param {DecodeReq} tx
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public txsDecodePost(tx: DecodeReq, options?: any) {
    return TransactionsApiFp(this.configuration).txsDecodePost(tx, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
   * @summary Encode a transaction to the Amino wire format
   * @param {EncodeReq} tx
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public txsEncodePost(tx: EncodeReq, options?: any) {
    return TransactionsApiFp(this.configuration).txsEncodePost(tx, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Search transactions by events.
   * @summary Search transactions
   * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
   * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
   * @param {number} [page] Page number
   * @param {number} [limit] Maximum number of items per page
   * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
   * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public txsGet(
    messageAction?: string,
    messageSender?: string,
    page?: number,
    limit?: number,
    txMinheight?: number,
    txMaxheight?: number,
    options?: any,
  ) {
    return TransactionsApiFp(this.configuration).txsGet(
      messageAction,
      messageSender,
      page,
      limit,
      txMinheight,
      txMaxheight,
      options,
    )(this.axios, this.basePath);
  }

  /**
   * Retrieve a transaction using its hash.
   * @summary Get a Tx by hash
   * @param {string} hash Tx hash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public txsHashGet(hash: string, options?: any) {
    return TransactionsApiFp(this.configuration).txsHashGet(hash, options)(
      this.axios,
      this.basePath,
    );
  }

  /**
   * Broadcast a signed tx to a full node
   * @summary Broadcast a signed tx
   * @param {BroadcastReq} txBroadcast
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public txsPost(txBroadcast: BroadcastReq, options?: any) {
    return TransactionsApiFp(this.configuration).txsPost(txBroadcast, options)(
      this.axios,
      this.basePath,
    );
  }
}
